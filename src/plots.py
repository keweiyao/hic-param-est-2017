"""
Generates plots / figures when run as a script.
Plot files are placed in the :file:`plots` directory.

By default, simply running ``python -m src.plots`` generates **ALL** plots,
which may not be desired.  Instead, one can pass a list of plots to generate:
``python -m src.plots plot1 plot2 ...``.  The full list of plots is shown in
the usage information ``python -m src.plots --help``.

Typing can be reduced by using shell brace expansion, e.g. ``python -m
src.plots observables_{design,posterior}`` for both ``observables_design`` and
``observables_posterior``.  In addition, plots may be given as paths to plot
filenames, which enables shell globbing, e.g. ``python -m src.plots
plots/observables_*``.

In the code, each plot is generated by a function tagged with the ``@plot``
decorator.
"""


import itertools
import logging
from pathlib import Path
import subprocess
import tempfile
import warnings

import h5py
import hsluv
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import lines
from matplotlib import patches
from matplotlib import ticker
from scipy import special
from scipy.interpolate import PchipInterpolator, interp1d
from sklearn.decomposition import PCA
from sklearn.gaussian_process import GaussianProcessRegressor as GPR
from sklearn.gaussian_process import kernels
from sklearn.mixture import GaussianMixture
from .emulator import Emulator

from . import workdir, systems, parse_system, expt, model, mcmc
from .design import Design
from .emulator import emulators
from matplotlib.gridspec import GridSpec
from scipy.optimize import brentq

fontsmall, fontnormal, fontlarge = 5, 6, 7
offblack = '#262626'
aspect = 1/1.618
resolution = 72.27
textwidth = 307.28987/resolution
textheight = 261.39864/resolution
fullwidth = 350/resolution
fullheight = 270/resolution

plt.rcdefaults()
plt.rcParams.update({
	'font.family': 'DejaVu Sans-Serif',
	'font.sans-serif': ['Lato'],
	'mathtext.fontset': 'custom',
	'mathtext.default': 'it',
	'mathtext.rm': 'sans',
	'mathtext.it': 'sans:italic:medium',
	'mathtext.cal': 'sans',
	'font.size': fontnormal,
	'legend.fontsize': fontnormal,
	'axes.labelsize': fontnormal,
	'axes.titlesize': fontlarge,
	'xtick.labelsize': fontsmall,
	'ytick.labelsize': fontsmall,
	'font.weight': 400,
	'axes.labelweight': 400,
	'axes.titleweight': 400,
	'lines.linewidth': .5,
	'lines.markersize': 3,
	'lines.markeredgewidth': 0,
	'patch.linewidth': .5,
	'axes.linewidth': .4,
	'xtick.major.width': .4,
	'ytick.major.width': .4,
	'xtick.minor.width': .4,
	'ytick.minor.width': .4,
	'xtick.major.size': 1.2,
	'ytick.major.size': 1.2,
	'xtick.minor.size': .8,
	'ytick.minor.size': .8,
	'xtick.major.pad': 1.5,
	'ytick.major.pad': 1.5,
	'axes.formatter.limits': (-5, 5),
	'axes.spines.top': False,
	'axes.spines.right': False,
	'axes.labelpad': 3,
	'text.color': offblack,
	'axes.edgecolor': offblack,
	'axes.labelcolor': offblack,
	'xtick.color': offblack,
	'ytick.color': offblack,
	'legend.numpoints': 1,
	'legend.scatterpoints': 1,
	'legend.frameon': False,
	'image.cmap': 'Blues',
	'image.interpolation': 'none',
	'pdf.fonttype': 42
})
cm1, cm2 = plt.cm.Blues(.8), plt.cm.Reds(.8)
cb,co,cg,cr = plt.cm.Blues(.6), \
	plt.cm.Oranges(.6), plt.cm.Greens(.6), plt.cm.Reds(.6)
offblack = '#262626'
gray = '0.8'


plotdir = workdir / 'plots'
plotdir.mkdir(exist_ok=True)

plot_functions = {}


def plot(f):
	"""
	Plot function decorator.  Calls the function, does several generic tasks,
	and saves the figure as the function name.

	"""
	def wrapper(*args, **kwargs):
		logging.info('generating plot: %s', f.__name__)
		f(*args, **kwargs)

		fig = plt.gcf()

		if not fig.get_tight_layout():
			set_tight(fig)

		plotfile = plotdir / '{}.png'.format(f.__name__)
		fig.savefig(str(plotfile), dpi=300)
		logging.info('wrote %s', plotfile)
		plt.close(fig)

	plot_functions[f.__name__] = wrapper

	return wrapper


def set_tight(fig=None, **kwargs):
	"""
	Set tight_layout with a better default pad.

	"""
	if fig is None:
		fig = plt.gcf()

	kwargs.setdefault('pad', .1)
	fig.set_tight_layout(kwargs)


def auto_ticks(ax, axis='both', minor=False, **kwargs):
	"""
	Convenient interface to matplotlib.ticker locators.

	"""
	axis_list = []

	if axis in {'x', 'both'}:
		axis_list.append(ax.xaxis)
	if axis in {'y', 'both'}:
		axis_list.append(ax.yaxis)

	for axis in axis_list:
		axis.get_major_locator().set_params(**kwargs)
		if minor:
			axis.set_minor_locator(ticker.AutoMinorLocator(minor))


def format_system(system):
	"""
	Format a system string into a display name, e.g.:

	>>> format_system('PbPb2760')
	'Pb+Pb 2.76 TeV'

	>>> format_system('AuAu200')
	'Au+Au 200 GeV'

	"""
	proj, energy = parse_system(system)

	if energy > 1000:
		energy /= 1000
		prefix = 'T'
	else:
		prefix = 'G'

	return '{} {} {}eV'.format('+'.join(proj), energy, prefix)


def darken(rgb, amount=.5):
	"""
	Darken a color by the given amount in HSLuv space.

	"""
	h, s, l = hsluv.rgb_to_hsluv(rgb)
	return hsluv.hsluv_to_rgb((h, s, (1 - amount)*l))


def obs_color_hsluv(obs, nPDF):
	"""
	Return a nice color for the given observable in HSLuv space.
	Use obs_color() to obtain an RGB color.

	"""
	if obs == 'RAA':
		if nPDF == 'EPPS':
			return 250, 90, 55
		else:
			return 130, 90, 55

	if 'V2' in obs:
		if nPDF == 'EPPS':
			return 250, 90, 55
		else:
			return 130, 90, 55

	if obs == 'qhat':
		if nPDF == 'EPPS':
			return 250, 90, 55
		else:
			return 130, 90, 55

	if obs == 'posterior':
		if nPDF == 'EPPS':
			return 250, 90, 55
		else:
			return 130, 90, 55

	raise ValueError('unknown observable: {} {}'.format(obs, subobs))


def obs_color(obs, nPDF):
	"""
	Return a nice color for the given observable.

	"""
	return hsluv.hsluv_to_rgb(obs_color_hsluv(obs, nPDF))


def _observables_plots():
	"""
	Metadata for observables plots.

	"""

	return [
		dict(
			title='V2',
			ylabel=(
				r'$v_{2}$'
			),
			xscale='log',
			xlim=(1, 24),
			ylim=(-.05, 0.4),
			height_ratio=1.0,
			subplots=[
				('ALICE', 'V2', 'D-avg', '30-50', dict(label='30-50(%)', scale=1)),
				('ALICE', 'V2', 'D-avg', '30-50-L', dict(label='30-50(%) \n $q_2$ low', scale=1)),
				('ALICE', 'V2', 'D-avg', '30-50-H', dict(label='30-50(%) \n $q_2$ high', scale=1))
			]
		),
		dict(
			title='RAA',
			ylabel=(
				r'$R_{AA}$'
			),
			xscale='log',
			xlim=(1, 50),
			ylim=(0, 1.2),
			height_ratio=1.0,
			subplots=[
				('ALICE', 'RAA', 'D-avg', '0-10', 
							dict(label='0-10(%)', scale=1)),
				('ALICE', 'RAA', 'D-avg', '30-50', 
							dict(label='30-50(%)', scale=1)),
				('ALICE', 'RAA', 'D-avg', '60-80', 
							dict(label='60-80(%)', scale=1)),
			]
		),
		dict(
			title='V2',
			ylabel=(
				r'$v_{2}$'
			),
			xscale='log',
			xlim=(1,40),
			ylim=(-0.05, 0.25),
			height_ratio=1.0,
			subplots=[
				('CMS', 'V2', 'D0', '0-10', dict(label='0-10(%)', scale=1)),
				('CMS', 'V2', 'D0', '10-30', dict(label='10-30(%)', scale=1)),
				('CMS', 'V2', 'D0', '30-50', dict(label='30-50(%)', scale=1))
			]
		),
		dict(
			title='RAA',
			ylabel=(
				r'$R_{AA}$'
			),
			xscale='log',
			xlim=(1, 100),
			ylim=(0, 1.2),
			height_ratio=1.0,
			subplots=[
				('CMS', 'RAA', 'D0', '0-10', dict(label='0-10(%)', scale=1)),
				('CMS', 'RAA', 'D0', '0-100', dict(label='0-100(%)', scale=1))
			]
		),
		dict(
			title='RAA',
			ylabel=(
				r'$R_{AA}$'
			),
			xscale='log',
			xlim=(1, 100),
			ylim=(0, 1.2),
			height_ratio=1.0,
			subplots=[
				('CMS', 'RAA', 'B', '0-100', dict(label='0-100(%)', scale=1)),
			]
		),
	]



@plot
def obs():
	fig = plt.figure(figsize=(fullwidth, .65*fullwidth))
	gs = GridSpec(9, 12)
	ax1 = plt.subplot(gs[0:3, 0:4])
	ax2 = plt.subplot(gs[0:3, 4:8])
	ax3 = plt.subplot(gs[0:3, 8:12])
	#ax4 = plt.subplot(gs[0:3, 9:12])
	ax5 = plt.subplot(gs[3:6, :4])
	ax6 = plt.subplot(gs[3:6, 4:8])
	ax7 = plt.subplot(gs[3:6, 8:12])
	ax8 = plt.subplot(gs[6:, :4])
	ax9 = plt.subplot(gs[6:, 4:8])
	ax10 = plt.subplot(gs[6:, 8:12])  

	from JetCalc.ExpCut import cuts as ExpCut
	#######LHC###########################
	f1 = h5py.File("./model_output/test/PbPb5020/obs.h5",'r')
	print(list(f1.values()))
	Raa = [		{	
					'cenb': p0['ALICE/Raa/cen-bins'].value,
					'pTb': p0['ALICE/Raa/pT-bins'].value,
					'y': p0['ALICE/Raa/D+D*/y'].value[:,:],
					'yerr': p0['ALICE/Raa/D+D*/yerr'].value[:,:]
				} for p0 in f1.values()
			]
	RaaCMS = [		{	
					'cenb': p0['CMS/Raa/cen-bins'].value,
					'pTb': p0['CMS/Raa/pT-bins'].value,
					'y': p0['CMS/Raa/D/y'].value[:,:],
					'yerr': p0['CMS/Raa/D/yerr'].value[:,:]
				} for p0 in f1.values()
			]
	v2D = [		{	
					'cenb': p0['CMS/vn_HF/cen-bins'].value,
					'pTb': p0['CMS/vn_HF/pT-bins'].value,
					'y': p0['CMS/vn_HF/D+D*/y'].value[:,:,0],
					'yerr': p0['CMS/vn_HF/D+D*/yerr'].value[:,:,0] 
				} for p0 in f1.values()
			]
	v3D = [		{	
					'cenb': p0['CMS/vn_HF/cen-bins'].value,
					'pTb': p0['CMS/vn_HF/pT-bins'].value,
					'y': p0['CMS/vn_HF/D+D*/y'].value[:,:,1],
					'yerr': p0['CMS/vn_HF/D+D*/yerr'].value[:,:,1] 
				} for p0 in f1.values()
			]



	# plot raa for PbPb of ALICE
	for j, (cen, cenn, ax) in enumerate(
				zip(ExpCut['ALICE']['Raa']['cenbins'],
				['0-10','30-50','60-80'],
				[ax1, ax2, ax3])
			):
		ax.set_ylim(0, 1.4)
		ax.set_xlim(0.9, 100)
		# calc
		if j != 0:
			for m, (iv, line, label) in enumerate(zip(Raa,
										['-','--','-.'],
										[r'$\alpha_s(Q\gtrsim\pi T)$',
										r'$\alpha_s(Q\gtrsim1.5\pi T)$']
										)):
				pT = (iv['pTb'][:,0]+iv['pTb'][:,1])/2.
				y = iv['y'][j]
				xerr = (iv['pTb'][:,1]-iv['pTb'][:,0])/2.
				yerr = iv['yerr'][j]
				ax.plot(pT[1:], y[1:], line, color=cr, label=label if j==1 else '', linewidth=1)
			ax.fill_between(pT[1:], Raa[0]['y'][j,1:], Raa[-1]['y'][j,1:], color=cr, alpha=0.3)
		ax.annotate("Pb+Pb {}-{}%".format(*cen), xy=(0.25, .95), xycoords='axes fraction')
		ax.semilogx()
		# exp-ALICE
		pTl, pTh, y, ystat, ysys = np.loadtxt("./prelim-exp/ALICE-Raa-D-{}.dat".format(cenn)).T
		pT = (pTl+pTh)/2.
		pTbar = (pTh-pTl)/2.
		ax.errorbar(pT, y, xerr=pTbar, yerr=ystat, fmt='D', label='ALICE, D' if j==0 else '', color='k', markersize=2, zorder=-1)
		for ix, iw, iy, iysys in \
			zip(pT, pTbar, y, ysys):
			il, ih = iy-iysys, iy+iysys
			ax.fill_between(
				[ix-iw, ix+iw],
				[il, il], [ih, ih],
				zorder=-10,
				facecolor='white', edgecolor='k'
			)
	# plot raa for PbPb of CMS
	ax = ax1
	j = 0
	for m, (iv, line, label) in enumerate(zip(RaaCMS,
									['-','--','-.'],
									[r'LO, $\alpha_s(Q\gtrsim\pi T)$',
									r'LO, $\alpha_s(Q\gtrsim1.5\pi T)$']
									)):
		pT = (iv['pTb'][:,0]+iv['pTb'][:,1])/2.
		y = iv['y'][j]
		xerr = (iv['pTb'][:,1]-iv['pTb'][:,0])/2.
		yerr = iv['yerr'][j]
		ax.plot(pT, y, line, color=cr, label=label if j==1 else '', linewidth=1)
	ax.fill_between(pT, RaaCMS[0]['y'][j], RaaCMS[-1]['y'][j], color=cr, alpha=0.3)
	
	pTl, pTh, y, ystat, ysys = np.loadtxt("./prelim-exp/CMS-Raa-0-10.dat".format(cenn)).T
	pT = (pTl+pTh)/2.
	pTbar = (pTh-pTl)/2.
	ax.errorbar(pT, y, xerr=pTbar, yerr=ystat, fmt='s', label='CMS, D', color=cb, markersize=2, zorder=-1)
	for ix, iw, iy, iysys in \
		zip(pT, pTbar, y, ysys):
		il, ih = iy-iysys, iy+iysys
		ax.fill_between(
			[ix-iw, ix+iw],
			[il, il], [ih, ih],
			zorder=-10,
			facecolor='white', edgecolor=cb
		)


	ax1.set_ylabel(r"$R_{AA}$")	
	

	# plot v2
	for j, (cen, cenn, ax) in enumerate(zip(
					ExpCut['CMS']['vn_HF']['cenbins'], 
					['0-10','10-30','30-50'],
					[ax5, ax6, ax7])
			):
		ax.set_ylim(-0.015, 0.2)
		ax.set_xlim(0.9, 100)
		# calc

		for m, (iv, line) in enumerate(zip(v2D,
								['-','--','-.']
								)):
			pT = (iv['pTb'][:,0]+iv['pTb'][:,1])/2.
			y = iv['y'][j]
			xerr = (iv['pTb'][:,1]-iv['pTb'][:,0])/2.
			yerr = iv['yerr'][j]
			ax.plot(pT, y, line, color=cr, linewidth=1)
		ax.fill_between(pT, v2D[0]['y'][j], v2D[-1]['y'][j], color=cr, alpha=0.3)
		ax.annotate("Pb+Pb {}-{}%".format(*cen), xy=(0.25, .95), xycoords='axes fraction')
		ax.semilogx()

		# exp CMS
		pTl, pTh, y, ystat, ysys = np.loadtxt("./official-exp/CMS-v2-D-{}.dat".format(cenn), usecols=[0,1,2,3,4]).T
		pT = (pTl+pTh)/2.
		pTbar = (pTh-pTl)/2.
		ax.errorbar(pT, y, xerr=pTbar, yerr=ystat, fmt='D', label='CMS, D${}^0$', color=cb, markersize=2, zorder=-1)
		for ix, iw, iy, iysys in \
			zip(pT, pTbar, y, ysys):
			il, ih = iy-iysys, iy+iysys
			ax.fill_between(
				[ix-iw, ix+iw],
				[il, il], [ih, ih],
				zorder=-10,
				facecolor='white', edgecolor=cb
			)

	# plot v3
	for j, (cen, cenn, ax) in enumerate(zip(
					ExpCut['CMS']['vn_HF']['cenbins'], 
					['0-10','10-30','30-50'],
					[ax8, ax9, ax10])
			):
		ax.set_ylim(-0.025, 0.11)
		ax.set_xlim(0.9, 100)
		# calc

		for m, (iv, line) in enumerate(zip(v3D,
								['-','--'],
								)):
			pT = (iv['pTb'][:,0]+iv['pTb'][:,1])/2.
			y = iv['y'][j]
			xerr = (iv['pTb'][:,1]-iv['pTb'][:,0])/2.
			yerr = iv['yerr'][j]
			ax.plot(pT, y, line, color=cr, linewidth=1)
		ax.fill_between(pT, v3D[0]['y'][j], v3D[-1]['y'][j], color=cr, alpha=0.3)
		ax.semilogx()

		# exp CMS
		pTl, pTh, y, ystat, ysys = np.loadtxt("./official-exp/CMS-v3-D-{}.dat".format(cenn), usecols=[0,1,2,3,4]).T
		pT = (pTl+pTh)/2.
		pTbar = (pTh-pTl)/2.
		ax.errorbar(pT, y, xerr=pTbar, yerr=ystat, fmt='D', label='CMS, D${}^0$', color=cb, markersize=2, zorder=-1)
		for ix, iw, iy, iysys in \
			zip(pT, pTbar, y, ysys):
			il, ih = iy-iysys, iy+iysys
			ax.fill_between(
				[ix-iw, ix+iw],
				[il, il], [ih, ih],
				zorder=-10,
				facecolor='white', edgecolor=cb
			)

	ax5.set_ylabel(r"$v_{2}$")	
	ax8.set_ylabel(r"$v_{3}$")	
	ax1.legend(loc="best")
	ax2.legend(loc="best")
	for ax in [ax1, ax2, ax3, ax5, ax6, ax7, ax8, ax9, ax10]:
		l, h = ax.get_ylim()
		ax.plot([5,5],[l,h*0.9],'k--', linewidth=.5)
	for ax in [ax2, ax3, ax6, ax7, ax9, ax10]:
		ax.set_yticklabels([])
	for ax in [ax8, ax9, ax10]:
		ax.set_xlabel(r"$p_T$ [GeV]")
	set_tight(fig, rect=[0.0, 0, 1, .95])



@plot
def Lido_poster():
	fig = plt.figure(figsize=(.8*fullwidth, .35*fullwidth))
	gs = GridSpec(1, 2)
	ax1 = plt.subplot(gs[0, 0])
	ax2 = plt.subplot(gs[0, 1]) 

	from JetCalc.ExpCut import cuts as ExpCut
	#######LHC###########################
	f1 = h5py.File("./model_output/main/PbPb5020/pythia-lido-pred.hdf5",'r')
	f2 = h5py.File("./model_output/main/PbPb5020/mclpm-pred.hdf5",'r')
	p0 = f1['pythia-ref'] # 
	p1 = f1['pythia-mu1d0-naive-2'] # 
	p3 = f1['pythia-mu1d0-harder'] # 
	Raa = [		{	'y': p1['ALICE/EPS09/Raa/D/mean'].value[:,:]\
						/p0['ALICE/EPS09/Raa/D/mean'].value[0,:],
					'yerr': p1['ALICE/EPS09/Raa/D/yerr'].value[:,:]\
							/p0['ALICE/EPS09/Raa/D/mean'].value[0,:]
				},

				{	'y': p3['ALICE/EPS09/Raa/D/mean'].value[:,:]\
						/p0['ALICE/EPS09/Raa/D/mean'].value[0,:],
					'yerr': p3['ALICE/EPS09/Raa/D/yerr'].value[:,:]\
							/p0['ALICE/EPS09/Raa/D/mean'].value[0,:],
				},
			]
	v2D = [		{	'y': p1['CMS/EPS09/vn2/D+D*/mean'].value[:,:,0],
						  'yerr': p1['CMS/EPS09/vn2/D+D*/yerr'].value[:,:,0] 
				},
				{	'y': p3['CMS/EPS09/vn2/D+D*/mean'].value[:,:,0],
						  'yerr': p3['CMS/EPS09/vn2/D+D*/yerr'].value[:,:,0] 
				}
			]



	# plot raa for PbPb
	ax = ax1; cen = [0,10]; cenn="0-10"
	ax.set_ylim(0, 1.2)
	ax.set_xlim(0.9, 100)
	#ax.plot([0.9, 100], [1,1],'k--', linewidth=0.3)
	# calc
	pTb = ExpCut['pred-pT']
	pT = np.mean(pTb, axis=1)
	pTbar = (pTb[:,1]-pTb[:,0])/2.
	ax.fill_between(pT[1:], Raa[0]['y'][0,1:], Raa[-1]['y'][0,1:], 
						facecolor=cr, edgecolor="none", alpha=0.35)
	for m, (iv, line, label) in enumerate(zip(Raa,
							['-','--','-.'],
							[r'w/ full vac. shower',
							 r'vetoed region removed',]
							)):
		ax.plot(pT[1:], iv['y'][0,1:], line, color=cr, linewidth=1)
	ax.annotate("Pb+Pb {}-{}%".format(*cen), xy=(0.3, 1.01), xycoords='axes fraction')
	ax.semilogx()
	#ax.set_yticks([0,.2,.4,.6,.8,1.,1.2])

	# interpolate calc
	fcalc = interp1d(pT[1:], Raa[-1]['y'][0,1:])
	
	# exp-ALICE
	pTl, pTh, y, ystat, ysys = np.loadtxt("./prelim-exp/ALICE-Raa-D-{}.dat".format(cenn)).T
	pT = (pTl+pTh)/2.
	pTbar = (pTh-pTl)/2.
	f_interp = fcalc(pT)
	#y /= f_interp; ystat /= f_interp; ysys/= f_interp
	ax.errorbar(pT, y, xerr=pTbar, yerr=ystat, fmt='s', label='ALICE, D', color='k', markersize=2, zorder=-1)
	for ix, iw, iy, iysys in \
		zip(pT, pTbar, y, ysys):
		il, ih = iy-iysys, iy+iysys
		ax.fill_between(
			[ix-iw, ix+iw],
			[il, il], [ih, ih],
			zorder=-10,
			facecolor='white', edgecolor='k'
		)
	# exp-CMS
	pTl, pTh, y, ystat, ysys = np.loadtxt("./prelim-exp/CMS-Raa-{}.dat".format(cenn)).T
	pT = (pTl+pTh)/2.
	pTbar = (pTh-pTl)/2.
	f_interp = fcalc(pT)
	#y /= f_interp; ystat /= f_interp; ysys/= f_interp
	ax.errorbar(pT, y, xerr=pTbar, yerr=ystat, fmt='o', label='CMS, D', color=cb, markersize=2, zorder=-1)
	for ix, iw, iy, iysys in \
		zip(pT, pTbar, y, ysys):
		il, ih = iy-iysys, iy+iysys
		ax.fill_between(
			[ix-iw, ix+iw],
			[il, il], [ih, ih],
			zorder=-10,
			facecolor='white', edgecolor=cb
		)
	ax.set_ylabel(r"$R_{AA}$ Exp./Theo.")	
	
	###############################
	ax = ax2; cen = [30,50]; cenn="30-50"
	# plot v2
	ax.set_ylim(-0.01, 0.25)
	ax.set_xlim(0.9, 100)
	#ax.plot([0.9, 100], [1,1],'k--', linewidth=0.3)
	# calc
	pTb = ExpCut['pred-pT']
	pT = np.mean(pTb, axis=1)
	pTbar = (pTb[:,1]-pTb[:,0])/2.
	ax.fill_between(pT[1:], v2D[0]['y'][2,1:], v2D[-1]['y'][2,1:], 
						facecolor=cr, edgecolor="none", alpha=0.35)
	for iv, line,label in zip(v2D,
							['-','--','-.'],
							[r'Unmodifed Pythia + Lido',
							 r'Subtracted Pythia + Lido',]
							):
		ax.plot(pT[1:], iv['y'][2,1:], line, label=label, color=cr, linewidth=1)
	ax.annotate("Pb+Pb {}-{}%".format(*cen), xy=(0.3, 1.01), xycoords='axes fraction')
	ax.semilogx()

	# interpolate calc
	fcalc = interp1d(pT[1:], v2D[-1]['y'][2,1:])

	# exp CMS
	pTl, pTh, y, ystat, ysys = np.loadtxt("./official-exp/CMS-v2-D-{}.dat".format(cenn), usecols=[0,1,2,3,4]).T
	pT = (pTl+pTh)/2.
	pTbar = (pTh-pTl)/2.
	f_interp = fcalc(pT)
	#y /= f_interp; ystat /= f_interp; ysys/= f_interp
	ax.errorbar(pT, y, xerr=pTbar, yerr=ystat, fmt='o', color=cb, markersize=2, zorder=-1)
	for ix, iw, iy, iysys in \
		zip(pT, pTbar, y, ysys):
		il, ih = iy-iysys, iy+iysys
		ax.fill_between(
			[ix-iw, ix+iw],
			[il, il], [ih, ih],
			zorder=-10,
			facecolor='white', edgecolor=cb
		)

	ax1.set_ylabel(r"$R_{AA}$")	
	ax2.set_ylabel(r"$v_{2}$")	
	#ax2.annotate(r"$\alpha_s(Q\geqslant\pi T)$, vetoed region removed", xy=(.05,.87), xycoords="axes fraction")
	ax1.legend(loc=(.3, .76))
	ax2.legend(loc=(.1, .76))
	for ax in [ax1, ax2]:
		ax.set_xlabel(r"$p_T$ [GeV]")
		#ax.set_yticklabels([])
	set_tight(fig, rect=[0.0, 0, 1, .95])


@plot
def v2ee():
	fig, ax = plt.subplots(1,1,sharex=True, #sharex=True, 
							figsize=(0.5*fullwidth, 0.35*fullwidth))
	from JetCalc.ExpCut import cuts as ExpCut
	with h5py.File("./model_output/main/PbPb5020/lhc-bc-pred.hdf5",'r') as f:
		p = f['00']
		v = {'y': p['ALICE/EPPS/v2_ee/D+D*/mean'].value[0,:,:],
			   'yerr': p['ALICE/EPPS/v2_ee/D+D*/yerr'].value[0,:,:] }
	pTb = ExpCut['pred-pT']
	pT = np.mean(pTb, axis=1)
	pTbar = (pTb[:,1]-pTb[:,0])/2.
	for j in range(2):
		ax.plot(pT, v['y'][:, j], linewidth=1)
		ax.set_ylabel(r"$v_2$")
		ax.set_xlabel(r"$p_T$ [GeV]")
		ax.set_ylim(-0.05, 0.3)
		ax.semilogx()
	# plot ALICE
	for j, cen in enumerate(['30-50-L','30-50-H']):
		pTl, pTh, y, ystat, ysys = np.loadtxt("./prelim-exp/ALICE-V2-D-{}.dat".format(cen)).T
		pT = (pTl+pTh)/2.
		pTbar = (pTh-pTl)/2.
		ax.errorbar(pT, y, xerr=pTbar, yerr=ystat, fmt='D', color='k', markersize=2, zorder=-1)
		for ix, iw, iy, iysys in \
			zip(pT, pTbar, y, ysys):
			il, ih = iy-iysys, iy+iysys
			ax.fill_between(
				[ix-iw, ix+iw],
				[il, il], [ih, ih],
				zorder=-10,
				facecolor='white', edgecolor='k'
			)
	ax.legend(loc='upper right')
	set_tight(fig, rect=[0, 0, .99, 0.99])

@plot
def pythia_baseline():
	
	def spectrum(fname, pTbins, _pid, dY=1, norm=1):
		pid, E, px, py, pz, w = np.loadtxt(fname).T
		w = w
		pT = np.sqrt(px**2 + py**2)
		pabs = np.sqrt(pT**2 + pz**2)
		yabs = np.abs(.5*np.log((pabs+pz)/(pabs-pz)))

		cut = (yabs<dY/2.) & (pid == _pid)
		pT = pT[cut]
		w = w[cut]
		H1, be = np.histogram(pT, bins=pTbins, weights=w*w)
		H2, be = np.histogram(pT, bins=pTbins, weights=w)
		Neff = H2**2/H1

		x = (be[1:]+be[:-1])/2.
		y = H2/(be[1:]-be[:-1])/dY*0.5*1e3*norm
		yerr = y/(Neff-1.)**0.5

		return x, y, yerr

	fig = plt.figure(figsize=(0.5*fullwidth, 0.5*fullwidth))
	gs = GridSpec(3, 1)
	ax1 = plt.subplot(gs[0:2, 0])
	ax2 = plt.subplot(gs[2, 0])

	D0 = expt.ppdata['pp7000']['dX/dp/dy']['D0']['MB']
	Dx = expt.ppdata['pp7000']['dX/dp/dy']['D+']['MB']
	Dstar = expt.ppdata['pp7000']['dX/dp/dy']['D*']['MB']
	
	pTbins = Dx['pT']
	pTw = [h-l for l, h in Dx['pT'] ]
	pTexp = Dx['x']
	expD0 = D0['y'][1:-1]
	expDx = Dx['y']
	expDstar = Dstar['y']
	expD0err = D0['yerr'].get('stat')[1:-1]
	expDxerr = Dx['yerr'].get('stat')
	expDstarerr = Dstar['yerr'].get('stat')
	expD = expD0 + expDx + expDstar
	expDerr = np.sqrt(expD0err**2 + expDxerr**2 + expDstarerr**2)

	norm = 232.028/1.20896e6
	pT, pythiaD0, pythiaD0err = spectrum("/home/wk42/random/Scattering/build/baseline/list-pp-D.dat", [*pTbins[:,0], pTbins[-1,1]], 421, dY=1, norm=norm)
	pT, pythiaDx, pythiaDxerr = spectrum("/home/wk42/random/Scattering/build/baseline/list-pp-D.dat", [*pTbins[:,0], pTbins[-1,1]], 411, dY=1, norm=norm)
	pT, pythiaDstar, pythiaDstarerr = spectrum("/home/wk42/random/Scattering/build/baseline/list-pp-D.dat", [*pTbins[:,0], pTbins[-1,1]], 413, dY=1, norm=norm)

	norm = 169.704/964885 
	pT, ApythiaD0, ApythiaD0err = spectrum("/home/wk42/random/Scattering/build/baseline/list-AA-D.dat", [*pTbins[:,0], pTbins[-1,1]], 421, dY=1, norm=norm)
	pT, ApythiaDx, ApythiaDxerr = spectrum("/home/wk42/random/Scattering/build/baseline/list-AA-D.dat", [*pTbins[:,0], pTbins[-1,1]], 411, dY=1, norm=norm)
	pT, ApythiaDstar, ApythiaDstarerr = spectrum("/home/wk42/random/Scattering/build/baseline/list-AA-D.dat", [*pTbins[:,0], pTbins[-1,1]], 413, dY=1, norm=norm)

	pythiaD = pythiaD0 + pythiaDx + pythiaDstar
	ApythiaD = ApythiaD0 + ApythiaDx + ApythiaDstar
	
	ax1.plot(pT, pythiaD,'r-')
	ax1.plot(pT, ApythiaD,'b-')
	ax2.plot(pT, ApythiaD/pythiaD, 'b--')
	for i, (ix, iw, il, ih, y, ystat, yth) in \
		enumerate(zip(pT, pTw, expD*0.95, expD*1.05, expD, expDerr, pythiaD)):
		label = "ALICE, D" 
		ax1.errorbar(ix, y, yerr=ystat, fmt='D', color=cr, label=label if i==0 else '')
		ax1.fill_between(
			[ix-iw/2., ix+iw/2.],
			[il, il], [ih, ih],
			zorder=-10,
			facecolor='white', edgecolor=cr
		)
		ax2.errorbar(ix, y/yth, yerr=ystat/yth, fmt='D', color=cr, label=label if i==0 else '')
		ax2.fill_between(
			[ix-iw/2., ix+iw/2.],
			[il/yth, il/yth], [ih/yth, ih/yth],
			zorder=-10,
			facecolor='white', edgecolor=cr
		)
	ax1.legend()
	ax1.semilogy()
	ax1.set_xticklabels([])
	ax1.set_ylabel(r'$d\sigma/dp_T/dy$ [$\mu$b/GeV]')
	ax1.set_title(r"Baseline: p+p $\rightarrow$ D")
		
	ax2.set_xlabel(r'$p_T$ [GeV]')
	ax2.set_ylabel('Data/Pythia')
	ax2.set_ylim(0,2)
	ax2.plot([0,25],[1,1],'k--',linewidth=.3)
	set_tight(fig, rect=[0, 0, .97, 1])

@plot
def design():
	"""
	Projection of a LH design into two dimensions.

	"""
	fig = plt.figure(figsize=(.5*textwidth, .5*textwidth))
	ratio = 10
	gs = plt.GridSpec(ratio + 1, ratio + 1)

	ax_j = fig.add_subplot(gs[1:, :-1])
	ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
	ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

	d = Design(systems[0])

	print((d.array[:,0]>.5) & (np.exp(d.array[:,1])<1.0) & 
			(np.exp(d.array[:,2])-1. < 1) & (np.exp(d.array[:,3])-1. < 1) )

	keys = ('mu', 'qhat_A')
	indices = tuple(d.keys.index(k) for k in keys)

	x, y = (d.array[:, i] for i in indices)
	ax_j.plot(x, y, 'o', color=plt.cm.Blues(0.75), mec='white', mew=.3)

	hist_kw = dict(bins=30, color=plt.cm.Blues(0.4), edgecolor='white', lw=.5)
	ax_x.hist(x, **hist_kw)
	ax_y.hist(y, orientation='horizontal', **hist_kw)

	for ax in fig.axes:
		ax.tick_params(top='off', right='off')
		spines = ['top', 'right']
		if ax is ax_x:
			spines += ['left']
		elif ax is ax_y:
			spines += ['bottom']
		for spine in spines:
			ax.spines[spine].set_visible(False)
		for ax_name in 'xaxis', 'yaxis':
			getattr(ax, ax_name).set_ticks_position('none')

	auto_ticks(ax_j)

	for ax in ax_x, ax_y:
		ax.tick_params(labelbottom='off', labelleft='off')

	for i, xy in zip(indices, 'xy'):
		for f, l in [('lim', d.range), ('label', d.labels)]:
			attr = 'set_{}{}'.format(xy, f)
			arg = l[i]
			print(attr, l, l[i])
			getattr(ax_j, attr)(arg)


@plot
def gp():
	"""
	Conditioning a Gaussian process.

	"""
	fig, axes = plt.subplots(
		figsize=(.47*textwidth, .9*textheight),
		nrows=2, sharex='col'
	)

	def dummy_optimizer(obj_func, initial_theta, bounds):
		return initial_theta, 0.

	gp = GPR(1.*kernels.RBF(.8), optimizer=dummy_optimizer)

	def sample_y(*args, **kwargs):
		with warnings.catch_warnings():
			warnings.simplefilter('ignore', RuntimeWarning)
			return gp.sample_y(*args, **kwargs)

	x = np.linspace(0, 5, 1000)
	X = x[:, np.newaxis]

	x_train = np.linspace(.5, 4.5, 4)
	X_train = x_train[:, np.newaxis]

	for title, ax in zip(['Random functions', 'Conditioned on data'], axes):
		if title.startswith('Conditioned'):
			y = sample_y(X_train, random_state=23158).squeeze()
			y -= .5*(y.max() + y.min())
			gp.fit(X_train, y)
			training_data, = plt.plot(x_train, y, 'o', color='.3', zorder=50)

		for s, c in zip(
				sample_y(X, n_samples=4, random_state=34576).T,
				['Blues', 'Greens', 'Oranges', 'Purples']
		):
			ax.plot(x, s, color=getattr(plt.cm, c)(.6))

		mean, std = gp.predict(X, return_std=True)
		std = ax.fill_between(x, mean - std, mean + std, color='.92')
		mean, = ax.plot(x, mean, color='.42', dashes=(3.5, 1.5))

		ax.set_ylim(-2, 2)
		ax.set_ylabel('Output')
		auto_ticks(ax)

		ax.set_title(title, y=.9)

	ax.set_xlabel('Input')
	ax.legend(*zip(*[
		(mean, 'Mean prediction'),
		(std, 'Uncertainty'),
		(training_data, 'Training data'),
	]), loc='lower left')
	set_tight(fig, h_pad=1)


@plot
def pca():
	fig = plt.figure(figsize=(.45*textwidth, .45*textwidth))
	ratio = 5
	gs = plt.GridSpec(ratio + 1, ratio + 1)

	ax_j = fig.add_subplot(gs[1:, :-1])
	ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
	ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

	x, y = (
		model.data['PbPb5020']['EPPS'][exp][obs][specie][cent]['Y'][:, index]
		for exp, obs, specie, cent, index in [('CMS', 'RAA', 'D0', '0-10', 5),
										  ('ALICE','V2', 'D-avg', '30-50', 2)]
	)
	x = np.log(x)
	xlabel = r'$R_{AA}, 0-10\%, 8 < p_T < 10$ [GeV]'
	ylabel = r'$v_2\{2\}, 30-50\%, 2 < p_T < 3$ [GeV]'
	xlim = -4, 0
	ylim = 0.05, 0.3

	cmap = plt.cm.Blues

	ax_j.plot(x, y, 'o', color=cmap(.75), mec='white', mew=.25, zorder=10)

	for d, ax, orientation in [(x, ax_x, 'vertical'), (y, ax_y, 'horizontal')]:
		ax.hist(
			d, bins=10,
			orientation=orientation, color=cmap(.4), edgecolor='white'
		)

	xy = np.column_stack([x, y])
	xymean = xy.mean(axis=0)
	xystd = xy.std(axis=0)
	xy -= xymean
	xy /= xystd
	pca = PCA().fit(xy)
	pc = (
		7 * xystd *
		pca.explained_variance_ratio_[:, np.newaxis] *
		pca.components_
	)

	for w, p in zip(pca.explained_variance_ratio_, pc):
		print(w)
		if np.all(p < 0):
			p *= -1
		p = p/(p**2).sum()**0.25*0.8
		print(p)
		ax_j.annotate(
			'', xymean + p, xymean, zorder=20,
			arrowprops=dict(
				arrowstyle='->', shrinkA=0, shrinkB=0,
				color=offblack, lw=.7
			)
		)
		ax_j.text(
			*(xymean + p + (.1, .002)*np.sign(p)), s='{:.0f}%'.format(100*w),
			color=offblack, ha='center', va='top' if p[1] < 0 else 'bottom',
			zorder=20
		)

	for ax in fig.axes:
		ax.tick_params(top='off', right='off')
		spines = ['top', 'right']
		if ax is ax_x:
			spines += ['left']
		elif ax is ax_y:
			spines += ['bottom']
		for spine in spines:
			ax.spines[spine].set_visible(False)
		for ax_name in 'xaxis', 'yaxis':
			getattr(ax, ax_name).set_ticks_position('none')

	for ax in ax_x, ax_y:
		ax.tick_params(labelbottom='off', labelleft='off')

	auto_ticks(ax_j)

	ax_j.set_xlim(xlim)
	ax_j.set_ylim(ylim)

	ax_j.set_xlabel(xlabel)
	ax_j.set_ylabel(ylabel)

	set_tight(pad=.1, h_pad=.3, w_pad=.3)



def boxplot(
		ax, percentiles, x=0, y=0, box_width=1, line_width=1,
		color=(0, 0, 0), alpha=.6, zorder=10
):
	"""
	Draw a minimal boxplot.

	`percentiles` must be a np.array of five numbers:

		whisker_low, quartile_1, median, quartile_3, whisker_high

	"""
	pl, q1, q2, q3, ph = percentiles + y

	# IQR box
	ax.add_patch(patches.Rectangle(
		xy=(x - .5*box_width, q1),
		width=box_width, height=(q3 - q1),
		color=color, alpha=alpha, lw=0, zorder=zorder
	))

	# median line
	ax.plot(
		[x - .5*box_width, x + .5*box_width], 2*[q2],
		lw=line_width, solid_capstyle='butt', color=color,
		zorder=zorder + 1
	)

	# whisker lines
	for y in [[q1, pl], [q3, ph]]:
		ax.plot(
			2*[x], y, lw=line_width, solid_capstyle='butt',
			color=color, alpha=alpha, zorder=zorder
		)


@plot
def diag_pca(system, nPDF):
	"""
	Diagnostic: histograms of principal components and scatterplots of pairs.

	"""
	Y = [g.y_train_ for g in emulators[nPDF][system].gps]
	n = len(Y)
	ymax = np.ceil(max(np.fabs(y).max() for y in Y))
	lim = (-ymax, ymax)

	fig, axes = plt.subplots(nrows=n, ncols=n, figsize=2*(n,))

	for y, ax in zip(Y, axes.diagonal()):
		ax.hist(y, bins=10)
		ax.set_xlim(lim)

	for ny, nx in zip(*np.tril_indices_from(axes, k=-1)):
		ax = axes[ny][nx]
		ax.scatter(Y[nx], Y[ny])
		ax.set_xlim(lim)
		ax.set_ylim(lim)
		axes[nx][ny].set_axis_off()

	for i in range(n):
		label = 'PC {}'.format(i)
		axes[-1][i].set_xlabel(label)
		axes[i][0].set_ylabel(label)


@plot
def diag_emu(system, nPDF):
	"""
	Diagnostic: plots of each principal component vs each input parameter,
	overlaid by emulator predictions at several points in design space.

	"""
	gps = emulators[nPDF][system].gps
	nrows = len(gps)
	ncols = gps[0].X_train_.shape[1]

	w = 1.8
	fig, axes = plt.subplots(
		nrows=nrows, ncols=ncols,
		figsize=(ncols*w, .8*nrows*w)
	)

	ymax = np.ceil(max(np.fabs(g.y_train_).max() for g in gps))
	ylim = (-ymax, ymax)

	design = Design(system)

	for ny, (gp, row) in enumerate(zip(gps, axes)):
		y = gp.y_train_

		for nx, (x, label, xlim, ax) in enumerate(zip(
				gp.X_train_.T, design.labels, design.range, row
		)):
			ax.plot(x, y, 'o', ms=.8, color='.75', zorder=10)

			x = np.linspace(xlim[0], xlim[1], 100)
			X = np.empty((x.size, ncols))

			for k, r in enumerate([.2, .5, .8]):
				X[:] = r*design.min + (1 - r)*design.max
				X[:, nx] = x
				mean, std = gp.predict(X, return_std=True)

				color = plt.cm.tab10(k)
				ax.plot(x, mean, lw=.2, color=color, zorder=30)
				ax.fill_between(
					x, mean - std, mean + std,
					lw=0, color=color, alpha=.3, zorder=20
				)

			ax.set_xlim(xlim)
			ax.set_ylim(ylim)

			ax.set_xlabel(label)
			ax.set_ylabel('PC {}'.format(ny))


if __name__ == '__main__':
	import argparse
	from matplotlib.mathtext import MathTextWarning

	warnings.filterwarnings(
		'ignore',
		category=MathTextWarning,
		message='Substituting with a symbol from Computer Modern.'
	)

	choices = list(plot_functions)

	def arg_to_plot(arg):
		arg = Path(arg).stem
		if arg not in choices:
			raise argparse.ArgumentTypeError(arg)
		return arg

	parser = argparse.ArgumentParser(description='generate plots')
	parser.add_argument(
		'plots', nargs='*', type=arg_to_plot, metavar='PLOT',
		help='{} (default: all)'.format(', '.join(choices).join('{}'))
	)
	args = parser.parse_args()

	if args.plots:
		for p in args.plots:
			plot_functions[p]()
	else:
		for f in plot_functions.values():
			f()

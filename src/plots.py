"""
Generates plots / figures when run as a script.
Plot files are placed in the :file:`plots` directory.

By default, simply running ``python -m src.plots`` generates **ALL** plots,
which may not be desired.  Instead, one can pass a list of plots to generate:
``python -m src.plots plot1 plot2 ...``.  The full list of plots is shown in
the usage information ``python -m src.plots --help``.

Typing can be reduced by using shell brace expansion, e.g. ``python -m
src.plots observables_{design,posterior}`` for both ``observables_design`` and
``observables_posterior``.  In addition, plots may be given as paths to plot
filenames, which enables shell globbing, e.g. ``python -m src.plots
plots/observables_*``.

In the code, each plot is generated by a function tagged with the ``@plot``
decorator.
"""

import os, subprocess
import itertools
import logging
from pathlib import Path
import warnings

import h5py
import hsluv
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import ticker
from sklearn.decomposition import PCA

from .emulator import Emulator, emulators
from . import workdir, systems, parse_system, expt, model, mcmc
from .design import Design

from matplotlib.gridspec import GridSpec

fontsmall, fontnormal, fontlarge = 5, 6, 7
offblack = '#262626'
aspect = 1/1.618
resolution = 72.27
textwidth = 307.28987/resolution
textheight = 261.39864/resolution
fullwidth = 350/resolution
fullheight = 270/resolution

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'DejaVu Sans-Serif',
    'font.sans-serif': ['Lato'],
    'mathtext.fontset': 'custom',
    'mathtext.default': 'it',
    'mathtext.rm': 'sans',
    'mathtext.it': 'sans:italic:medium',
    'mathtext.cal': 'sans',
    'font.size': fontnormal,
    'legend.fontsize': fontnormal,
    'axes.labelsize': fontnormal,
    'axes.titlesize': fontlarge,
    'xtick.labelsize': fontsmall,
    'ytick.labelsize': fontsmall,
    'font.weight': 400,
    'axes.labelweight': 400,
    'axes.titleweight': 400,
    'lines.linewidth': .5,
    'lines.markersize': 3,
    'lines.markeredgewidth': 0,
    'patch.linewidth': .5,
    'axes.linewidth': .4,
    'xtick.major.width': .4,
    'ytick.major.width': .4,
    'xtick.minor.width': .4,
    'ytick.minor.width': .4,
    'xtick.major.size': 1.2,
    'ytick.major.size': 1.2,
    'xtick.minor.size': .8,
    'ytick.minor.size': .8,
    'xtick.major.pad': 1.5,
    'ytick.major.pad': 1.5,
    'axes.formatter.limits': (-5, 5),
    'axes.spines.top': False,
    'axes.spines.right': False,
    'axes.labelpad': 3,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
    'image.cmap': 'Blues',
    'image.interpolation': 'none',
    'pdf.fonttype': 42
})
cm1, cm2 = plt.cm.Blues(.8), plt.cm.Reds(.8)
cb,co,cg,cr = plt.cm.Blues(.6), \
    plt.cm.Oranges(.6), plt.cm.Greens(.6), plt.cm.Reds(.6)
offblack = '#262626'
gray = '0.8'


plotdir = workdir / 'plots'
plotdir.mkdir(exist_ok=True)

plot_functions = {}


def plot(f):
    """
    Plot function decorator.  Calls the function, does several generic tasks,
    and saves the figure as the function name.

    """
    def wrapper(*args, **kwargs):
        logging.info('generating plot: %s', f.__name__)
        f(*args, **kwargs)

        fig = plt.gcf()

        if not fig.get_tight_layout():
            set_tight(fig)

        plotfile = plotdir / '{}.png'.format(f.__name__)
        fig.savefig(str(plotfile), dpi=300)
        logging.info('wrote %s', plotfile)
        plt.close(fig)

    plot_functions[f.__name__] = wrapper

    return wrapper


def set_tight(fig=None, **kwargs):
    """
    Set tight_layout with a better default pad.

    """
    if fig is None:
        fig = plt.gcf()

    kwargs.setdefault('pad', .1)
    fig.set_tight_layout(kwargs)


def auto_ticks(ax, axis='both', minor=False, **kwargs):
    """
    Convenient interface to matplotlib.ticker locators.

    """
    axis_list = []

    if axis in {'x', 'both'}:
        axis_list.append(ax.xaxis)
    if axis in {'y', 'both'}:
        axis_list.append(ax.yaxis)

    for axis in axis_list:
        axis.get_major_locator().set_params(**kwargs)
        if minor:
            axis.set_minor_locator(ticker.AutoMinorLocator(minor))


def format_system(system):
    """
    Format a system string into a display name, e.g.:

    >>> format_system('PbPb2760')
    'Pb+Pb 2.76 TeV'

    >>> format_system('AuAu200')
    'Au+Au 200 GeV'

    """
    proj, energy = parse_system(system)

    if energy > 1000:
        energy /= 1000
        prefix = 'T'
    else:
        prefix = 'G'

    return '{} {} {}eV'.format('+'.join(proj), energy, prefix)


def darken(rgb, amount=.5):
    """
    Darken a color by the given amount in HSLuv space.

    """
    h, s, l = hsluv.rgb_to_hsluv(rgb)
    return hsluv.hsluv_to_rgb((h, s, (1 - amount)*l))


def obs_color_hsluv(obs, nPDF):
    """
    Return a nice color for the given observable in HSLuv space.
    Use obs_color() to obtain an RGB color.

    """
    if obs == 'RAA':
        return 250, 90, 55

    if 'V2' in obs:
        return 250, 90, 55

    if obs == 'qhat':
        return 250, 90, 55

    if obs == 'posterior':
        return 250, 90, 55

    raise ValueError('unknown observable: {} {}'.format(obs, subobs))


def obs_color(obs, nPDF):
    """
    Return a nice color for the given observable.

    """
    return hsluv.hsluv_to_rgb(obs_color_hsluv(obs, nPDF))

lattice1_x = [1.46, 2.20, 2.93]
lattice1_y = [1.8, 2.0, 2.3]
lattice1_stat = [0.7, 0.4, 0.4]
lattice1_sys = [(0.5, 1.3), (1.2, 0.6), (1.1, 0.2)]
lattice2_x = [1.04102920332607,
1.09086415407343,
1.2418949863598,
1.49949352441474,
1.93950565736037,
]
lattice2_y = [4.80608444754841,
6.22087578147966,
4.04148418878713,
4.45467839268429,
9.77960354476739,
]
lattice2_stat = [0.827511828685804,
0.8275118286858,
1.26110735597276,
0.157638419496596,
4.01977969716318,
]
lattice2_sys = [(1.61552417882614,    3.27117695189699),
(2.20684799928101,    3.94131998210016),
(1.41865590179804,    4.25650694742203),
(1.45806550667218,    2.71917286264494),
(5.911350857451,    6.6604928447451),
]


a0 = 4.*np.pi/9.
Lambda2 = 0.2**2
afix=1.0
def alpha_s(T, mu):    
    Q2 = (mu*np.pi*T)**2
    if Q2/Lambda2 > np.exp(a0/afix):
        return a0/np.log(Q2/Lambda2)
    else:
        return afix

alpha_s = np.vectorize(alpha_s)
def pQCD_small(E, T, mu, cut):
    mD2 = 6*np.pi*T**2*alpha_s(T, mu)
    mT2 = (mu*np.pi*T)**2
    Q2 = cut*mD2
    log0 = np.log(1. + mT2/mD2)
    log1 = np.max([np.log(mT2/Lambda2),a0])
    log2 = np.max([np.log(Q2/Lambda2),a0])
    logs = log0 + log1*(1. - log1/log2)
    if Q2 < mT2:
        logs = np.log(1. + Q2/mD2)
    return 4./3.*alpha_s(T, mu) * T * mD2 * (logs - .5)

def pQCD_small_L(E, T, mu, cut):
    mD2 = 6*np.pi*T**2*alpha_s(T, mu)
    mT2 = (mu*np.pi*T)**2
    Q2 = cut*mD2
    minf2 = mD2/2.
    log0 = np.log(1. + mT2/minf2)
    log1 = np.max([np.log(mT2/Lambda2),a0])
    log2 = np.max([np.log(Q2/Lambda2),a0])
    logs = log0 + log1*(1. - log1/log2)
    if Q2 < mT2:
        logs = np.log(1. + Q2/minf2)
    return 4./3.*alpha_s(T, mu) * T * minf2 * (logs - .5)

def pQCD_large(filename):
    with h5py.File(filename, 'r') as f:
        attr = f["/Boltzmann/cq2cq/rate/tensor"].attrs
        El, Eh, EN = attr['low-0'], attr['high-0'], attr['shape-0']
        Tl, Th, TN = attr['low-1'], attr['high-1'], attr['shape-1']
        E = np.linspace(El, Eh, EN)
        T = np.linspace(Tl, Th, TN)
        qhat_large = f["/Boltzmann/cq2cq/rate/tensor/5"].value \
            +  f["/Boltzmann/cq2cq/rate/tensor/10"].value \
            +  f["/Boltzmann/cg2cg/rate/tensor/5"].value \
            +  f["/Boltzmann/cg2cg/rate/tensor/10"].value
        dpz = f["/Boltzmann/cq2cq/rate/vector/3"].value \
            +  f["/Boltzmann/cg2cg/rate/vector/3"].value 
        R = f["/Boltzmann/cq2cq/rate/scalar/0"].value \
            +  f["/Boltzmann/cg2cg/rate/scalar/0"].value 
        qhat_large_L = f["/Boltzmann/cq2cq/rate/tensor/15"].value \
            +  f["/Boltzmann/cg2cg/rate/tensor/15"].value \
            -dpz**2/R
        
    return E, T, qhat_large, qhat_large_L

pQCD_small = np.vectorize(pQCD_small)
pQCD_small_L = np.vectorize(pQCD_small_L)
def qhat_NP(E, T, mu, K, p, q, a, b, gamma):
    Tc = 0.154
    p0 = np.sqrt(E**2-1.3**2)
    mD2 = 6*np.pi*T**2*alpha_s(T, mu)
    mD = mD2**.5
    M = 1.3
    p0 = (E**2-M**2)**.5
    return 5.*K/(1+(a*T/Tc)**p)/(1+(b*E/T)**q) * T**3
qhat_NP = np.vectorize(qhat_NP)

@plot 
def alpha_s_posterior():
    def alpha_s(Q2, T, mu):
        a0 = 4.*np.pi/9.
        Lambda2 = 0.2**2
        afix=1.0
        Q2 = np.max([Q2, (mu*np.pi*T)**2])
        if Q2/Lambda2 > np.exp(a0/afix):
            return a0/np.log(Q2/Lambda2)
        else:
            return afix

    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g = Design(systems[0]).array.T
    mu0 = np.exp(lnm)

    chain = mcmc.Chain()
    data = chain.load(*chain.keys)
    np.random.seed(1)
    index = np.random.choice(range(len(data)), 400)
    samples = data[index]
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g, _ = samples.T
    mu1 = np.exp(lnm)


    fig, ax = plt.subplots(1,1,figsize=(.35*fullwidth, .35*fullwidth))

    T = 0.3
    
    Q = np.linspace(0.5, 100, 1000)
    ax.plot(Q, [alpha_s(x, 0, 0) for x in Q**2],'k:', color='gray')

    Q = np.linspace(0.2, 100, 1000)
    a0 = np.array([[alpha_s(x, T, m) for x in Q**2] for m in mu0])
    a1 = np.array([[alpha_s(x, T, m) for x in Q**2] for m in mu1])
    ax.fill_between(Q, np.percentile(a0, 0, axis=0), \
                       np.percentile(a0, 100, axis=0), color='gray', alpha=0.4)        
    ax.fill_between(Q, np.percentile(a1, 5, axis=0), \
                       np.percentile(a1, 95, axis=0), color='red', alpha=0.4)        
    ax.plot(Q, np.percentile(a1, 50, axis=0), 'k--')        
    ax.semilogx()        
    ax.set_xlabel(r"$Q$ [GeV]")
    ax.set_ylabel(r"$\alpha_s(Q, T)$")
    ax.annotate(r"$T = {:1.2f}$ GeV".format(T), xy=(.5, .8), xycoords="axes fraction")
    ax.set_ylim(0,1)
    ax.set_xlim(1e-1,3e1)

@plot 
def qhat_prior():
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g = Design(systems[0]).array.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)
    c = np.exp(lnc)

    fig, axes = plt.subplots(3,1,figsize=(.3*fullwidth, .5*fullwidth))

    for n, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
        name = '{0:03d}'.format(n)
        E, T, qhat_large, _ = pQCD_large("../Lido_Bayes_Tables/table-production-main/table-"+name+".h5")    
        for eid, ax in zip([0,9,100], axes):    
            qhat_pQCD = qhat_large[eid,:]/T**3+pQCD_small(E[eid], T, im, ic)/T**3
            Delta_qhat = qhat_NP(E[eid], T, im, ik, ip, iq, ia, ib, ig)/T**3
            qhat = qhat_pQCD + Delta_qhat
            #ax.plot(T, qhat_pQCD, color=cb, alpha=0.3, linewidth=2)
            ax.plot(T, qhat, color=cr, alpha=0.2, linewidth=1.5)
    axes[0].legend()
    axes[2].set_xlabel(r'$T$ [GeV]')
    for eid, ax in zip([0,10,100], axes):
        ax.set_ylabel(r'$\hat{q}/T^3$')
        ax.annotate(r"$E = {:1.1f}$ [GeV]".format(E[eid]), xy=(.4, .7), xycoords="axes fraction")


@plot 
def ER_prior():
    # load prior
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g = Design(systems[0]).array.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)
    c = np.exp(lnc)
    Prior = np.zeros([250, 80, 3])
    for n, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
        print(n)
        name = '{0:03d}'.format(n)
        E, T, qhat_large, qhat_large_L = pQCD_large("../Lido_Bayes_Tables/table-production-main/table-"+name+".h5")    
        for i, tid in enumerate([1,4,8]):    
            qhat_pQCD = qhat_large[::5,tid]+pQCD_small(E[::5], T[tid], im, ic)
            qhat_pQCD_L = qhat_large_L[::5,tid]+pQCD_small_L(E[::5], T[tid], im, ic)
            Delta_qhat = qhat_NP(E[::5], T[tid], im, ik, ip, iq, ia, ib, ig)
            qhat = qhat_pQCD + Delta_qhat
            qhatL = qhat_pQCD_L + Delta_qhat/2.*(E[::5]/1.3)**ig
            Prior[n, :, i] = 2*qhatL/qhat
    
    # plotting
    fig, axes = plt.subplots(3,1,figsize=(.3*fullwidth, 0.5*fullwidth))

    t = [T[1],T[4],T[8]]
    for i, ax in enumerate(axes):
        for n in range(250):
            ax.plot(E[::5], Prior[n, :, i], color='r', alpha=0.3, linewidth=1.)
        ax.semilogy()
        ax.set_xlim(0, 100)
        ax.set_ylim(1e-1,1e2)
        ax.set_ylabel(r'$2\Delta \hat{q}_L/\hat{q}$')
        ax.annotate(r"$T = {:1.2f}$ [GeV]".format(t[i]), xy=(.4, .1), xycoords="axes fraction")

    axes[-1].set_xlabel(r"$E$ [GeV]")


@plot 
def ER_posterior():
    chain = mcmc.Chain()
    data = chain.load(*chain.keys)
    np.random.seed(1)
    index = np.random.choice(range(len(data)), 400)
    samples = data[index]
    
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g, _ = samples.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)
    c = np.exp(lnc)

    pQCDdir = "./cache/qhat_pQCD_posterior/"
    if os.path.exists(pQCDdir):
        pass
    else:
        os.makedirs(pQCDdir)
        for i, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
            cmd = "Lido-TabGen -s ~/.local/share/settings.xml -t {:s}/{:03d}.h5 -c {:1.5f} -m {:1.5f}".format(pQCDdir, i, ic, im)
            subprocess.call(cmd, shell=True)


    # plotting
    fig, axes = plt.subplots(3,1,figsize=(.3*fullwidth, 0.5*fullwidth))
    # load posterior
    Post = np.zeros([400, 80, 3])
    for n, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
        print(n)
        name = '{0:03d}'.format(n)
        E, T, qhat_large, qhat_large_L = pQCD_large(pQCDdir + "/"+name+".h5")    
        for i, tid in enumerate([1,4,8]):
            qhat_pQCD = qhat_large[::5,tid]+pQCD_small(E[::5], T[tid], im, ic)
            qhat_pQCD_L = qhat_large_L[::5,tid]+pQCD_small_L(E[::5], T[tid], im, ic)
            Delta_qhat = qhat_NP(E[::5], T[tid], im, ik, ip, iq, ia, ib, ig)
            qhat = qhat_pQCD + Delta_qhat
            qhatL = qhat_pQCD_L + Delta_qhat/2.*(E[::5]/1.3)**ig
            Post[n, :, i] = 2*qhatL/qhat

    # load prior
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g = Design(systems[0]).array.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)
    c = np.exp(lnc)
    Prior = np.zeros([250, 80, 3])
    pQCD_prior = np.zeros([((c<=4.1) & (3.9<=c)).sum(), 80, 3])
    nn = 0
    for n, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
        print(n)
        name = '{0:03d}'.format(n)
        E, T, qhat_large, qhat_large_L = pQCD_large("../Lido_Bayes_Tables/table-production-main/table-"+name+".h5")    
        for i, tid in enumerate([1,4,8]):    
            qhat_pQCD = qhat_large[::5,tid]+pQCD_small(E[::5], T[tid], im, ic)
            qhat_pQCD_L = qhat_large_L[::5,tid]+pQCD_small_L(E[::5], T[tid], im, ic)
            Delta_qhat = qhat_NP(E[::5], T[tid], im, ik, ip, iq, ia, ib, ig)
            qhat = qhat_pQCD + Delta_qhat
            qhatL = qhat_pQCD_L + Delta_qhat/2.*(E[::5]/1.3)**ig
            Prior[n, :, i] = 2*qhatL/qhat
            if ic <= 4.1 and ic >= 3.9:
                pQCD_prior[nn, :, i] = 2*qhat_pQCD_L/qhat_pQCD
                if i==2:
                   nn += 1 
    

    t = [T[1],T[4],T[8]]


    for i, ax in enumerate(axes):
        if ax.is_first_col():
            ax.set_ylabel(r"$2\hat{q}_L/\hat{q}$")
            ax.fill_between(E[::5], np.min(Prior[:,:,i], axis=0), \
                        np.max(Prior[:,:,i], axis=0), color='gray', alpha=0.4)
            ax.fill_between(E[::5], np.min(pQCD_prior[:,:,i], axis=0), \
                                                np.max(pQCD_prior[:,:,i], axis=0), color='blue', alpha=0.4)

            ax.fill_between(E[::5], np.percentile(Post[:,:,i], 2.5, axis=0), \
                            np.percentile(Post[:,:,i], 97.5, axis=0), color='red', alpha=0.4)            
        if i==2:
            ax.set_xlabel(r'$E$ [GeV]')
        ax.set_xlim(0, 100)
        ax.set_ylim(1e-1,1e2)
        ax.semilogy()
        ax.annotate(r"$T = {:1.2f}$ [GeV]".format(t[i]), xy=(.4, .1), xycoords="axes fraction")

@plot 
def qhat_posterior():
    chain = mcmc.Chain()
    data = chain.load(*chain.keys)
    np.random.seed(1)
    index = np.random.choice(range(len(data)), 400)
    samples = data[index]
    
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g, _ = samples.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)
    c = np.exp(lnc)

    pQCDdir = "./cache/qhat_pQCD_posterior/"
    if os.path.exists(pQCDdir):
        pass
    else:
        os.makedirs(pQCDdir)
        for i, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
            cmd = "Lido-TabGen -s ~/.local/share/settings.xml -t {:s}/{:03d}.h5 -c {:1.5f} -m {:1.5f}".format(pQCDdir, i, ic, im)
            subprocess.call(cmd, shell=True)


    # plotting
    fig, axes = plt.subplots(3,1,figsize=(fullwidth*0.3, .5*fullwidth))
    # load posterior
    Post = np.zeros([index.size, 3, 16])
    for n, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
        name = '{0:03d}'.format(n)
        E, T, qhat_large, qhat_large_L = pQCD_large(pQCDdir + "/"+name+".h5")    
        for i, eid in enumerate([0,10,50]):    
            qhat_pQCD = qhat_large[eid,:]+pQCD_small(E[eid], T, im, ic)
            Delta_qhat = qhat_NP(E[eid], T, im, ik, ip, iq, ia, ib, ig)
            qhat = qhat_pQCD + Delta_qhat
            Post[n, i, :] = qhat/T**3

    # load prior
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g = Design(systems[0]).array.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)
    c = np.exp(lnc)
    Prior = np.zeros([250, 3, 16])
    for n, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
        name = '{0:03d}'.format(n)
        E, T, qhat_large, qhat_large_L = pQCD_large("../Lido_Bayes_Tables/table-production-main/table-"+name+".h5")    
        for i, eid in enumerate([0,10,100]):    
            qhat_pQCD = qhat_large[eid,:]+pQCD_small(E[eid], T, im, ic)
            Delta_qhat = qhat_NP(E[eid], T, im, ik, ip, iq, ia, ib, ig)
            qhat = qhat_pQCD + Delta_qhat
            Prior[n, i, :] = qhat/T**3
    

    e = [E[0],E[10],E[100]]


    for i, ax in enumerate(axes):
        if ax.is_first_col():
            ax.set_ylabel(r"$\hat{q}/T^3$")
        ax.fill_between(T, np.min(Prior[:,i,:], axis=0), \
                        np.max(Prior[:,i,:], axis=0), color='gray', alpha=0.4)
        
        ax.fill_between(T, np.percentile(Post[:,i,:], 2.5, axis=0), \
                            np.percentile(Post[:,i,:], 97.5, axis=0), color='red', alpha=0.4)            
        if i==2:
            ax.set_xlabel(r'$T$ [GeV]')
        ax.set_xlim(0.15, 0.5)
        ax.set_ylim(0, 40)
        ax.annotate(r"$E = {:1.1f}$ [GeV]".format(e[i]), xy=(.4, .7), xycoords="axes fraction")

@plot 
def Ds_posterior():
    chain = mcmc.Chain()
    data = chain.load(*chain.keys)
    np.random.seed(1)
    index = np.random.choice(range(len(data)), 400)
    samples = data[index]
    
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g, _ = samples.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)
    c = np.exp(lnc)

    pQCDdir = "./cache/qhat_pQCD_posterior/"
    if os.path.exists(pQCDdir):
        pass
    else:
        os.makedirs(pQCDdir)
        for i, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
            cmd = "Lido-TabGen -s ~/.local/share/settings.xml -t {:s}/{:03d}.h5 -c {:1.5f} -m {:1.5f}".format(pQCDdir, i, ic, im)
            subprocess.call(cmd, shell=True)


    # plotting
    fig, ax = plt.subplots(1,1,figsize=(.4*fullwidth, 0.35*fullwidth))
    # load posterior
    Post = np.zeros([index.size, 16])
    for n, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
        name = '{0:03d}'.format(n)
        E, T, qhat_large, qhat_large_L = pQCD_large(pQCDdir + "/"+name+".h5")    
        qhat_pQCD = qhat_large[0,:]+pQCD_small(E[0], T, im, ic)
        Delta_qhat = qhat_NP(E[0], T, im, ik, ip, iq, ia, ib, ig)
        qhat = qhat_pQCD + Delta_qhat
        Post[n, :] = 8*np.pi*T**3/qhat
    # load prior
    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g = Design(systems[0]).array.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)
    c = np.exp(lnc)
    Prior = np.zeros([250, 16])
    for n, (im, ik, ip, iq, ia, ib, ic, ig) in enumerate(zip(mu, K, p, q, a, b, c, g)):
        name = '{0:03d}'.format(n)
        E, T, qhat_large, qhat_large_L = pQCD_large("../Lido_Bayes_Tables/table-production-main/table-"+name+".h5")    
        qhat_pQCD = qhat_large[0,:]+pQCD_small(E[0], T, im, ic)
        Delta_qhat = qhat_NP(E[0], T, im, ik, ip, iq, ia, ib, ig)
        qhat = qhat_pQCD + Delta_qhat
        Prior[n, :] = 8*np.pi*T**3/qhat

    Tc = 0.154
    ax.fill_between(T/Tc, np.min(Prior, axis=0), \
                    np.max(Prior, axis=0), color='gray', alpha=0.4)
    
    ax.fill_between(T/Tc, np.percentile(Post, 2.5, axis=0), \
                        np.percentile(Post, 97.5, axis=0), color='red', alpha=0.4)        


    #lattice
    # lattice 1
    _,caps,_ = ax.errorbar(lattice2_x, lattice2_y,  yerr=lattice2_stat, fmt='o', color=cb, linewidth=1., label='lattice, static', capsize=1.5)
    for cap in caps:
        cap.set_markeredgewidth(.05)
    ax.errorbar(lattice2_x, lattice2_y,  yerr=np.array(lattice2_sys).T, fmt='o', color=cb, linewidth=0.6, markersize=1)

    # lattice 2
    _,caps,_ = ax.errorbar(lattice1_x, lattice1_y,  yerr=lattice1_stat, fmt='^', color=cg, label='lattice, charm', capsize=1.5)
    for cap in caps:
        cap.set_markeredgewidth(.05)
    ax.errorbar(lattice1_x, lattice1_y,  yerr=np.array(lattice1_sys).T, fmt='^', color=cg, linewidth=0.6, markersize=1)
    # lattice 3
    kappa_l = 1.8
    kappa_h = 3.4
    kappa_m = (1.8+3.4)/2.
    Dl = 4*np.pi/kappa_h
    Dh = 4*np.pi/kappa_l
    Dm = 4*np.pi/kappa_m
    ax.errorbar([1.5], [Dm], yerr=[[Dm-Dl], [Dh-Dm]], fmt='sk', label='lattice, static, continuum', zorder=10)

    ax.legend(loc='best')
    ax.set_xlabel(r'$T/T_c$')
    ax.set_ylabel(r'$2\pi T D_s$')
    ax.set_xlim(1, 3)
    ax.set_ylim(0, 25)




@plot
def parametrizations():
    a0 = 4.*np.pi/9.
    Lambda2 = 0.2**2
    afix=1.0
    def alpha_s(T, mu):    
        Q2 = (mu*np.pi*T)**2
        if Q2/Lambda2 > np.exp(a0/afix):
            return a0/np.log(Q2/Lambda2)
        else:
            return afix
    alpha_s = np.vectorize(alpha_s)
    def g_s(T, mu):
        return np.sqrt(4*np.pi*alpha_s(T, mu))

    def pQCD(E, T, mu):
        mD2 = 6*np.pi*T**2*alpha_s(T, mu)
        mT2 = (mu*np.pi*T)**2
        Q2 = 2*E*T
        log0 = np.log(1. + mT2/mD2)
        log1 = np.max([np.log(mT2/Lambda2),a0])
        log2 = np.max([np.log(Q2/Lambda2),a0])
        logs = log0 + log1*(1. - log1/log2)
        if Q2 < mT2:
            logs = np.log(1. + Q2/mD2)
        
        return .5*4./3.*alpha_s(T, mu) * T*mD2 * logs/T**3
    pQCD = np.vectorize(pQCD)

    def param1(E, T, mu, K, p, q, a, b, gamma):
        g = g_s(T, mu)
        qhat0 = pQCD(E, T, mu)
        Tc = 0.154
        p0 = np.sqrt(E**2-1.3**2)
        mD2 = 6*np.pi*T**2*alpha_s(T, mu)
        mD = mD2**.5
        M = 1.3
        return K*(1+(a*2)**p)*(1+b**q)/(1+(a*T/Tc)**p)/(1+(b*E/T)**q),\
               K*(1+(a*2)**p)*(1+b**q)/(1+(a*T/Tc)**p)/(1+(b*E/T)**q) * (E/M)**gamma

    tau0, lnc, lnR, lnm, K, p, q, lna, lnb, g = Design(systems[0]).array.T
    mu = np.exp(lnm)
    a = np.exp(lna)
    b = np.exp(lnb)

    T = np.linspace(.154, .6, 100)

    fig, axes = plt.subplots(1,4,figsize=(fullwidth, 0.35*fullwidth))
    for ax1, E in zip(axes.T, [1.3,10,100]):
        for i, (im, ik, ip, iq, ia, ib, ig) in enumerate(zip(mu, K, p, q, a, b, g)):
            k0 = pQCD(E, T, im)
            ax1.plot(T, k0, color=cb, alpha=0.3, label='pQCD' if i==0 else '')

            kperp, kpara = param1(E, T, im, ik, ip, iq, ia, ib, ig)
            ax1.plot(T, k0+kperp, color=cr, alpha=0.3, label=r'pQCD+$\Delta\kappa$' if i==0 else '')
            ax1.plot(T, kperp, color=cg, alpha=0.3, label=r'$\Delta\kappa$' if i==0 else '')
            

    for ax1, E in zip(axes.T, [1.3,10,100]):
        for im, line in zip([1, 1.5, 2], ['-','-.','--']):
            ax1.plot(T, pQCD(E, T, im), line, color='k', linewidth=.7)
        
        ax1.set_xlabel(r'$T$ [GeV]')
        ax1.set_title(r'$E={:1.1f}$ [GeV]'.format(E))

    axes[0].set_ylabel(r'$\kappa_T/T^3$')    
    axes[0].legend(loc='best')
    for i, (im, ik, ip, iq, ia, ib, ig) in enumerate(zip(mu, K, p, q, a, b, g)):
        E = np.linspace(1.3,100,100)
        kperp, kpara = param1(E, T, im, ik, ip, iq, ia, ib, ig)
        axes[-1].plot(E, kperp/kpara, color=cr, alpha=0.4, label=r'perp/para' if i==0 else '')
    #axes[-1].semilogx()
    axes[-1].set_ylabel(r'$\Delta\kappa_T/\Delta\kappa_L$')
    axes[-1].set_xlabel(r'$E$ [GeV]')


def obs(posterior=False, ratio=False, fmap=None, violin_plot=False):
    fig, axes = plt.subplots(figsize=(fullwidth, .7*fullwidth),
            ncols=3, nrows=3, sharex=True)
    
    def plot_exp(exp, j, scale=1., color='k'):
        for i, (ix, iy, ixe, isys, istat) in enumerate(zip(
                                exp['x'], 
                                exp['y']/scale, 
                                (exp['xbins'][:,1]-exp['xbins'][:,0])/2., 
                                exp['yerr']['sys']/scale, 
                                exp['yerr']['stat']/scale
                                )
                            ):
            ax.errorbar(ix, iy, yerr=istat, 
                    fmt='D', 
                    label='CMS, $D^0$' if i==j==0 else '', 
                    color=color, markersize=2, zorder=-1)
            ax.fill_between([ix-ixe,ix+ixe], 
                        [iy-isys,iy-isys], [iy+isys,iy+isys],
                        edgecolor=color, facecolor='None')

    def plot_this(xs, ys, xb):
        if posterior:
            if fmap == None:
                if violin_plot:
                    violin = ax.violinplot(list(ys.T), xs[0], 
                            widths=(xb[0,:,1]-xb[0,:,0]), 
                            showextrema=True, showmedians=True)
                    for b in violin['bodies']:
                        b.set_color(cb)
                    for partname in ('cbars','cmins','cmaxes','cmedians'):
                        vp = violin[partname]
                        vp.set_edgecolor(cb)
                        vp.set_linewidth(.0)
                else:
                    ax.fill_between(xs[0], np.percentile(ys,2.5, axis=0),
                        np.percentile(ys,97.5, axis=0), color=cb, alpha=0.5
                    )
                    ax.plot(xs[0], np.percentile(ys,50, axis=0), 'k--', linewidth=.6
                    )
            else: 
                for x, y in zip(xs, ys):
                    ax.plot(x, y, color='green')
        else:
            for x, y in zip(xs, ys):
                ax.plot(x, y, color='green', alpha=0.1, zorder=-100)
    from JetCalc.ExpCut import cuts as ExpCut
    axes[0,0].semilogx()
    axes[0,0].set_xlim(0.9, 100)
    #######LHC###########################
    expdata = expt.data['Pb-Pb-5020']

    if posterior:
        samples = mcmc.Chain().samples(1000) \
                    if fmap == None else fmap

    ############ ALICE RAA #####################
    for j, (cenbin, cen, ax) in enumerate(
                zip(ExpCut['ALICE']['Raa']['cenbins'],
                ['0-10','30-50','60-80'],
                axes[0])
            ):
        ax.annotate("ALICE Pb+Pb {}-{}%".format(*cenbin), 
                    xy=(0.25, .95), xycoords='axes fraction');ax.annotate(r"$R_{AA}$",
                    xy=(0.5, .8), xycoords='axes fraction', fontsize=8)
    
        # exp-ALICE
        exp = expdata['ALICE']['RAA']['D-avg'][cen]

        # calc
        calc = model.data['Pb-Pb-5020']['ALICE']['RAA']['D-avg'][cen]
        xb = calc['xbins']
        xs = calc['x']
        ys = samples['Pb-Pb-5020']['ALICE']['RAA']['D-avg'][cen] \
             if posterior else calc['y']
        if not ratio:
            plot_this(xs, ys, xb)
            plot_exp(exp, j, color='k')
            ax.set_ylim(0, 1.4)
        else:
            ymedian = np.median(ys, axis=0)
            plot_this(xs, ys/ymedian, xb)
            plot_exp(exp, j, scale=ymedian,color='k')
            ax.set_ylim(0,3)

    ############ CMS RAA #####################
    for j, (cenbin, cen, ax) in enumerate(
                zip(ExpCut['CMS']['Raa']['cenbins'],
                ['0-10','0-100'],
                axes[1,:2])
            ):
        ax.annotate(r"CMS Pb+Pb {}-{}%".format(*cenbin), 
                    xy=(0.25, .95), xycoords='axes fraction');ax.annotate(r"$R_{AA}$",
                    xy=(0.5, .8), xycoords='axes fraction', fontsize=8)

        # exp-ALICE
        exp = expdata['CMS']['RAA']['D0'][cen]

        # calc
        calc = model.data['Pb-Pb-5020']['CMS']['RAA']['D0'][cen]
        xb = calc['xbins']
        xs = calc['x']
        ys = samples['Pb-Pb-5020']['CMS']['RAA']['D0'][cen] \
             if posterior else calc['y']

        if not ratio:
            plot_this(xs, ys, xb)
            plot_exp(exp, j, color='k')
            ax.set_ylim(0, 1.4)
        else:
            ymedian = np.median(ys, axis=0)
            plot_this(xs, ys/ymedian, xb)
            plot_exp(exp, j, scale=ymedian, color='k')
            ax.set_ylim(0,3)

    ############ ALICE V2 #####################
    for j, (cenbin, cen, ax) in enumerate(
                zip(ExpCut['ALICE']['vn_HF']['cenbins'],
                ['30-50'],
                axes[1,2:])
            ):
        ax.annotate(r"ALICE Pb+Pb {}-{}%".format(*cenbin), 
                    xy=(0.25, .95), xycoords='axes fraction');         ax.annotate(r"$v_{2}$",   
                    xy=(0.5, .8), xycoords='axes fraction', fontsize=8)

        # exp-ALICE
        exp = expdata['ALICE']['V2']['D-avg'][cen]
        # calc
        calc = model.data['Pb-Pb-5020']['ALICE']['V2']['D-avg'][cen]
        xb = calc['xbins']
        xs = calc['x']
        ys = samples['Pb-Pb-5020']['ALICE']['V2']['D-avg'][cen] \
             if posterior else calc['y']

        if not ratio:
            plot_this(xs, ys, xb)
            plot_exp(exp, j, color='orange')
            ax.set_ylim(-.05,.3)
        else:
            ymedian = np.median(ys, axis=0)
            plot_this(xs, ys/ymedian, xb)
            plot_exp(exp, j, scale=ymedian, color='orange')
            ax.set_ylim(0,3)

    ############ CMS V2 #####################
    for j, (cenbin, cen, ax) in enumerate(
                zip(ExpCut['CMS']['vn_HF']['cenbins'],
                ['0-10','10-30','30-50'],
                axes[2])
            ):
        ax.annotate(r"CMS Pb+Pb {}-{}%".format(*cenbin), 
                    xy=(0.25, .95), xycoords='axes fraction');ax.annotate(r"$v_{2}$",
                    xy=(0.5, .8), xycoords='axes fraction', fontsize=8)


        # exp-ALICE
        exp = expdata['CMS']['V2']['D0'][cen]
        # calc
        calc = model.data['Pb-Pb-5020']['CMS']['V2']['D0'][cen]
        xb = calc['xbins']
        xs = calc['x']
        ys = samples['Pb-Pb-5020']['CMS']['V2']['D0'][cen] \
             if posterior else calc['y']
        if not ratio:
            plot_this(xs, ys, xb)
            plot_exp(exp, j, color='orange')
            ax.set_ylim(-.05,.3)
        else:
            ymedian = np.median(ys, axis=0)
            plot_this(xs, ys/ymedian, xb)
            plot_exp(exp, j, scale=ymedian, color='orange')
            ax.set_ylim(0,3)

    for ax in axes.flatten():
        if ax.is_last_row():
            ax.set_xlabel(r"$p_T$ [GeV]")
    set_tight(fig, rect=[0.02, 0.01, 1, .99])

@plot
def obs_prior():
    obs(posterior=False, ratio=False)

@plot
def obs_posterior():
    obs(posterior=True, ratio=False)

@plot
def obs_ratio():
    obs(posterior=False, ratio=True)

@plot
def obs_ratio_posterior():
    obs(posterior=True, ratio=True)


@plot
def pythia_baseline():
    
    fig = plt.figure(figsize=(0.5*fullwidth, 0.5*fullwidth))
    gs = GridSpec(3, 1)
    ax1 = plt.subplot(gs[0:2, 0])
    ax2 = plt.subplot(gs[2, 0])

    pT, pTl, pTh, y, ystat, _, ysys, _ = np.loadtxt("official-exp/CMS-yield-pp.dat").T

    y *= 1e-9 * 2
    ystat *= 1e-9 * 2
    ysys *= 1e-9 * 2
    f1 = h5py.File("./cache/model/main/Pb-Pb-5020/obs.h5",'r')
    calc = f1['/ref/CMS/D+D*/y'].value/(pTh-pTl)
    ce = f1['/ref/CMS/D+D*/yerr'].value/(pTh-pTl)
    
    ax1.plot(pT, calc,'-', color=cb)
    ax1.fill_between(pT, calc-ce, calc+ce, alpha=0.3, color=cb)
    ax2.fill_between(pT, 1-ce/calc, 1+ce/calc, alpha=0.3, color=cb)
    for i, (ix, iw, il, ih, y, ystat, yth) in \
        enumerate(zip(pT, (pTh-pTl)/2., y-ysys, y+ysys, y, ystat, calc)):
        label = r"CMS, $p+p \rightarrow D^0$ / BR." 
        ax1.errorbar(ix, y, yerr=ystat, fmt='D', color=cb, label=label if i==0 else '')
        ax1.fill_between(
            [ix-iw, ix+iw],
            [il, il], [ih, ih],
            zorder=-10,
            facecolor='white', edgecolor=cb
        )
        ax2.errorbar(ix, y/yth, yerr=ystat/yth, fmt='D', color=cb, label=label if i==0 else '')
        ax2.fill_between(
            [ix-iw, ix+iw],
            [il/yth, il/yth], [ih/yth, ih/yth],
            zorder=-10,
            facecolor='white', edgecolor=cb
        )

    pT, pTl, pTh, yAA, yAAstat, _, yAAsys, _ = np.loadtxt("official-exp/CMS-yield-AA-0-10.dat").T
    yAA *= 1e-9 * 2
    yAAstat *= 1e-9 * 2
    yAAsys *= 1e-9 * 2
    calcAA = f1['/190.dat/CMS/D+D*/y'].value[0,:]/(pTh-pTl)
    ce = f1['/190.dat/CMS/D+D*/yerr'].value[0,:]/(pTh-pTl)
    ax1.plot(pT, calcAA,'--', color=cr)
    ax1.fill_between(pT, calcAA-ce, calcAA+ce, alpha=0.3, color=cr)
    ax2.fill_between(pT, 1-ce/calcAA, 1+ce/calcAA, alpha=0.3, color=cr)
    for i, (ix, iw, il, ih, y, ystat, yth) in \
        enumerate(zip(pT, (pTh-pTl)/2., yAA-yAAsys, yAA+yAAsys, yAA, yAAstat, calcAA)):
        label = r"CMS, $Pb+Pb \rightarrow D^0$ / BR." 
        ax1.errorbar(ix, y, yerr=ystat, fmt='D', color=cr, label=label if i==0 else '')
        ax1.fill_between(
            [ix-iw/2., ix+iw/2.],
            [il, il], [ih, ih],
            zorder=-10,
            facecolor='white', edgecolor=cr
        )
        ax2.errorbar(ix, y/yth, yerr=ystat/yth, fmt='D', color=cr, label=label if i==0 else '')
        ax2.fill_between(
            [ix-iw, ix+iw],
            [il/yth, il/yth], [ih/yth, ih/yth],
            zorder=-10,
            facecolor='white', edgecolor=cr
        )
    
    ax1.legend()
    ax1.semilogy()
    ax1.set_xticklabels([])
    ax1.set_ylabel(r'$d\sigma/dp_T/dy$ [$m$b/GeV]')
    ax1.set_xlim(1,100)
    ax1.semilogx()

    ax2.semilogx()
    ax2.set_xlabel(r'$p_T$ [GeV]')
    ax2.set_ylabel('Data/Theory')
    ax2.set_ylim(0,2.5)
    ax2.set_xlim(1,100)
    ax2.plot([1,100],[1,1],'k--',linewidth=.3)
    set_tight(fig, rect=[0, 0, .97, 1])

@plot
def design(transformed=False):
    """
    Projection of a LH design into two dimensions.

    """
    def transform(key, label, val):
        if key=='lnc':
            return r"$c$", np.exp(val)
        if key=='lna':
            return r"$a$", np.exp(val)
        if key=='lnb':
            return r"$b$", np.exp(val)
        return label, val
    d = Design(systems[0])
    fig, axes = plt.subplots(d.ndim, d.ndim, figsize=(textwidth, textwidth))
    for i,k1 in enumerate(d.keys):
        for j,k2 in enumerate(d.keys):
            ax = axes[i,j]
            id1 = d.keys.index(k1)
            id2 = d.keys.index(k2)
            lx, hx = d.min[id2], d.max[id2]
            ly, hy = d.min[id1], d.max[id1]
            data1 = d.array[:, id1]
            data2 = d.array[:, id2]
            label1 = d.labels[id1]
            label2 = d.labels[id2]
            if transformed:
                label1, data1 = transform(k1, label1, data1)
                label2, data2 = transform(k2, label2, data2)
                _, lx = transform(k2, label2, lx)
                _, hx = transform(k2, label2, hx)
                _, ly = transform(k1, label1, ly)
                _, hy = transform(k1, label1, hy)
            rx = hx-lx
            ry = hy-ly
            if id1 < id2:
                ax.set_visible(False)
                continue
            if id1 == id2:
                ax.hist(data1, 20,histtype='step')
                ax.set_xlim(lx-rx*.1, hx+rx*.1)
                ax.set_ylim(ymin=0.)
                ax.set_xticks([lx, hx])
            else:
                ax.scatter(data2, data1, .4)
                ax.set_xlim(lx-rx*.1, hx+rx*.1)
                ax.set_ylim(ly-ry*.1, hy+ry*.1)
                ax.set_xticks([lx, hx])
                ax.set_yticks([ly, hy])
                ax.set_xticklabels([])
                ax.set_yticklabels([])
                if ax.is_last_row():
                    ax.set_xticks([lx, hx])
                    ax.set_xticklabels(["{:1.1f}".format(lx), "{:1.1f}".format(hx)])
                if ax.is_first_col():
                    ax.set_yticks([ly, hy])
                    ax.set_yticklabels(["{:1.1f}".format(ly), "{:1.1f}".format(hy)])

            if ax.is_last_row():
                ax.set_xlabel(label2)
                    
            if ax.is_first_col():
                ax.set_ylabel(label1)
    set_tight(pad=.1, h_pad=.02, w_pad=.02)

def format_ci(samples, ci=.9):
    """
    Compute the median and a credible interval for an array of samples and
    return a TeX-formatted string.

    """
    cil, cih = mcmc.credible_interval(samples, ci=ci)
    median = np.median(samples)
    ul = median - cil
    uh = cih - median

    # decide precision for formatting numbers
    # this is NOT general but it works for the present data
    if abs(median) < .2 and ul < .02:
        precision = 3
    elif abs(median) < 1:
        precision = 2
    else:
        precision = 1

    fmt = str(precision).join(['{:#.', 'f}'])

    return ''.join([
        '$', fmt.format(median),
        '_{-', fmt.format(ul), '}',
        '^{+', fmt.format(uh), '}$'
    ]), {'m': median, 'l': ul, 'h': uh}


@plot
def posterior():
    chain = mcmc.Chain()
    data = chain.load(*chain.keys).T
    ndims, nsamples = data.shape
    print(data.shape)
    cmap = plt.get_cmap('Blues')
    cmap.set_bad('white')

    fig, axes = plt.subplots(
        nrows=ndims, ncols=ndims,
        figsize=(textwidth, textwidth)
    )
    d = Design('Pb-Pb-5020')
    labels, ranges, samples = d.transform(data, Texp=False)
    for i, row in enumerate(axes):
        for j, ax in enumerate(row):
            x = samples[j]
            y = samples[i]
            xlabel = labels[j]
            xlim = ranges[j]
            ylabel = labels[i]
            ylim = ranges[i]
            if i==j:
                ax.hist(x, bins=40, histtype='step', normed=True)
                stex, dict = format_ci(x)
                ax.annotate(stex, xy=(.5, .1), xycoords="axes fraction",
                            ha='center', va='bottom', fontsize=4.5)
                ax.set_xlim(*xlim)
            if i>j:
                ax.hist2d(x, y, bins=40, cmap=cmap)
                ax.set_xlim(*xlim)
                ax.set_ylim(*ylim)
            if i<j:
                ax.axis('off')
            if ax.is_first_col():
                ax.set_ylabel(ylabel, fontsize=5)
                l = ylim[1]-ylim[0]
                ax.set_yticks([ylim[0]+l*.1, ylim[1]-l*.1])
                ax.set_yticklabels(["{:1.1f} ".format(ylim[0]), 
                                    " {:1.1f}".format(ylim[1])], fontsize=5)
            else:
                ax.set_yticks([])
            if ax.is_last_row():
                ax.set_xlabel(xlabel, fontsize=5)
                l = xlim[1]-xlim[0]
                ax.set_xticks([xlim[0]+l*.1, xlim[1]-l*.1])
                ax.set_xticklabels(["{:1.1f} ".format(xlim[0]), 
                                    " {:1.1f}".format(xlim[1])], fontsize=5)
            else:
                ax.set_xticks([])
    set_tight(pad=.0, h_pad=.0, w_pad=.0)


@plot
def pca():
    fig = plt.figure(figsize=(.45*textwidth, .45*textwidth))
    ratio = 5
    gs = plt.GridSpec(ratio + 1, ratio + 1)

    ax_j = fig.add_subplot(gs[1:, :-1])
    ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
    ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

    x, y = (
        model.data['PbPb5020']['EPPS'][exp][obs][specie][cent]['Y'][:, index]
        for exp, obs, specie, cent, index in [('CMS', 'RAA', 'D0', '0-10', 5),
                                          ('ALICE','V2', 'D-avg', '30-50', 2)]
    )
    x = np.log(x)
    xlabel = r'$R_{AA}, 0-10\%, 8 < p_T < 10$ [GeV]'
    ylabel = r'$v_2\{2\}, 30-50\%, 2 < p_T < 3$ [GeV]'
    xlim = -4, 0
    ylim = 0.05, 0.3

    cmap = plt.cm.Blues

    ax_j.plot(x, y, 'o', color=cmap(.75), mec='white', mew=.25, zorder=10)

    for d, ax, orientation in [(x, ax_x, 'vertical'), (y, ax_y, 'horizontal')]:
        ax.hist(
            d, bins=10,
            orientation=orientation, color=cmap(.4), edgecolor='white'
        )

    xy = np.column_stack([x, y])
    xymean = xy.mean(axis=0)
    xystd = xy.std(axis=0)
    xy -= xymean
    xy /= xystd
    pca = PCA().fit(xy)
    pc = (
        7 * xystd *
        pca.explained_variance_ratio_[:, np.newaxis] *
        pca.components_
    )

    for w, p in zip(pca.explained_variance_ratio_, pc):
        print(w)
        if np.all(p < 0):
            p *= -1
        p = p/(p**2).sum()**0.25*0.8
        print(p)
        ax_j.annotate(
            '', xymean + p, xymean, zorder=20,
            arrowprops=dict(
                arrowstyle='->', shrinkA=0, shrinkB=0,
                color=offblack, lw=.7
            )
        )
        ax_j.text(
            *(xymean + p + (.1, .002)*np.sign(p)), s='{:.0f}%'.format(100*w),
            color=offblack, ha='center', va='top' if p[1] < 0 else 'bottom',
            zorder=20
        )

    for ax in fig.axes:
        ax.tick_params(top='off', right='off')
        spines = ['top', 'right']
        if ax is ax_x:
            spines += ['left']
        elif ax is ax_y:
            spines += ['bottom']
        for spine in spines:
            ax.spines[spine].set_visible(False)
        for ax_name in 'xaxis', 'yaxis':
            getattr(ax, ax_name).set_ticks_position('none')

    for ax in ax_x, ax_y:
        ax.tick_params(labelbottom='off', labelleft='off')

    auto_ticks(ax_j)

    ax_j.set_xlim(xlim)
    ax_j.set_ylim(ylim)

    ax_j.set_xlabel(xlabel)
    ax_j.set_ylabel(ylabel)

    set_tight(pad=.1, h_pad=.3, w_pad=.3)


@plot
def diag_pca():
    """
    Diagnostic: histograms of principal components and scatterplots of pairs.

    """
    Y = [g.y_train_ for g in emulators["Pb-Pb-5020"].gps]
    n = len(Y)
    ymax = np.ceil(max(np.fabs(y).max() for y in Y))
    lim = (-ymax, ymax)

    fig, axes = plt.subplots(nrows=n, ncols=n, figsize=2*(n,))

    for y, ax in zip(Y, axes.diagonal()):
        ax.hist(y, bins=10)
        ax.set_xlim(lim)

    for ny, nx in zip(*np.tril_indices_from(axes, k=-1)):
        ax = axes[ny][nx]
        ax.scatter(Y[nx], Y[ny])
        ax.set_xlim(lim)
        ax.set_ylim(lim)
        axes[nx][ny].set_axis_off()

    for i in range(n):
        label = 'PC {}'.format(i)
        axes[-1][i].set_xlabel(label)
        axes[i][0].set_ylabel(label)

@plot
def emu_self_validation():
    validation = emulators["Pb-Pb-5020"].validation
    emul = validation['Emulator']
    calc = validation['Truth']
    err = validation['Error']
    ipc = emul.shape[1]
    n = int(np.sqrt(ipc))
    fig, axes = plt.subplots(
        nrows=n, ncols=n,
        figsize=(textwidth, textwidth)
    )    
    for i, ax in enumerate(axes.flatten()):
        ax.errorbar(emul[:,i], calc[:,i], yerr=err[:,i], fmt='bo')
        ax.set_xlabel("Emulated PC{:d}".format(i))
        ax.set_ylabel("True PC{:d}".format(i))
        ax.plot([-4,4],[-4,4],'r--')
        H, b = np.histogram((emul[:,i]-calc[:,i])/err[:,i], bins=21, normed=True)
        x = (b[1:]+b[:-1])/2.
        ax.bar(x, H*3, bottom=-3)
        ax.set_ylim([-4,4])
        ax.set_xlim([-4,4])

@plot
def validation():
    d = Design('Pb-Pb-5020', npoints=50, validation=True)
    fig, axes = plt.subplots(
        nrows=2, ncols=2,
        figsize=(textwidth*.8, textwidth*.8)
    )    
    chain = mcmc.Chain()
    preds = chain._predict(d.array, return_cov=True)

    dev0 = []
    dev1 = []
    for i, pset in enumerate(d.array):
        ax = axes[0,0]
        ax1 = axes[1,0]
        for cen, color in zip(['0-10','10-30','30-50'],'rgb'):
            y = preds['Pb-Pb-5020'][0]['CMS']['V2']['D0'][cen][i]
            dy = preds['Pb-Pb-5020'][1][('CMS','V2','D0',cen),
                                        ('CMS','V2','D0',cen)][i]
            dy = np.diag(dy)**0.5
            calc = model.data_validation['Pb-Pb-5020']['CMS']['V2']['D0'][cen][i]['y']
            ax.errorbar(calc, y, yerr=dy, fmt='o', color=color, alpha=0.2, label="CMS "+cen if i==0 else '')
            ax1.scatter(np.abs(calc-y), dy, color=color, alpha=0.2)
            dev0 = np.concatenate([dev0, (y-calc)/dy])
        cen = '30-50'
        y = preds['Pb-Pb-5020'][0]['ALICE']['V2']['D-avg'][cen][i]
        dy = preds['Pb-Pb-5020'][1][('ALICE','V2','D-avg',cen),
                                    ('ALICE','V2','D-avg',cen)][i]
        dy = np.diag(dy)**0.5
        calc = model.data_validation['Pb-Pb-5020']['ALICE']['V2']['D-avg'][cen][i]['y']
        ax.errorbar(calc, y, yerr=dy, fmt='o', color='orange', alpha=0.2, label="ALICE "+cen if i==0 else '')
        ax1.scatter(np.abs(calc-y), dy, color=color, alpha=0.2)
        dev0 = np.concatenate([dev0, (y-calc)/dy])

        ax = axes[0,1]
        ax1 = axes[1,1]
        for cen, color in zip(['0-10','30-50','60-80'],'rgb'):
            y = preds['Pb-Pb-5020'][0]['ALICE']['RAA']['D-avg'][cen][i]
            dy = preds['Pb-Pb-5020'][1][('ALICE','RAA','D-avg',cen),
                                        ('ALICE','RAA','D-avg',cen)][i]
            dy = np.diag(dy)**0.5
            calc = model.data_validation['Pb-Pb-5020']['ALICE']['RAA']['D-avg'][cen][i]['y']
            ax.errorbar(calc, y, yerr=dy, fmt='o', color=color, alpha=0.2, label="ALICE "+cen if i==0 else '')
            ax1.scatter(np.abs(calc-y), dy, color=color, alpha=0.2)
            dev1 = np.concatenate([dev0, (y-calc)/dy])
        for cen, color in zip(['0-10','0-100'],['orange','k']):
            y = preds['Pb-Pb-5020'][0]['CMS']['RAA']['D0'][cen][i]
            dy = preds['Pb-Pb-5020'][1][('CMS','RAA','D0',cen),
                                        ('CMS','RAA','D0',cen)][i]
            dy = np.diag(dy)**0.5
            calc = model.data_validation['Pb-Pb-5020']['CMS']['RAA']['D0'][cen][i]['y']
            dev1 = np.concatenate([dev0, (y-calc)/dy])
            ax.errorbar(calc, y, yerr=dy, fmt='o', color=color, alpha=0.2, label="CMS "+cen if i==0 else '')
            ax1.scatter(np.abs(calc-y), dy, color=color, alpha=0.2)

    axes[0,0].plot([-.01,.3],[-.01,.3], 'k--')
    axes[0,0].legend(loc=(0,.65))
    x = np.linspace(-3,3,100)
    y = np.exp(-0.5*x**2)/np.sqrt(2*np.pi)
    #axes[1,0].hist(dev0, 30, histtype='step', normed=True)
    #axes[1,0].plot(x, y, 'k--')    
    #axes[0,1].plot([-.03,1.6],[-.03,1.6], 'k--')    
    #axes[1,1].hist(dev1, 30, histtype='step', normed=True)
    #axes[1,1].plot(x, y, 'k--')    
    axes[0,0].set_xlabel(r"Calculated $v_2$")
    axes[0,0].set_ylabel(r"Emulated $v_2$")
    axes[0,1].legend(loc=(0,.58))
    axes[0,1].set_xlabel(r"Calculated $R_{AA}$")
    axes[0,1].set_ylabel(r"Emulated $R_{AA}$")
    axes[1,0].set_xlabel(r"|True deviation|")
    axes[1,1].set_xlabel(r"|True deviation|")
    axes[1,0].set_ylabel(r"Estimated std")
    axes[1,0].set_yticks([0,0.01,0.02])
    axes[1,1].set_ylabel(r"Estimated std")
    x = np.linspace(0,1,10)
    import matplotlib as mpl
    mpl.rcParams['hatch.linewidth'] = 0.2
    axes[1,0].plot(x, x/3., 'k--', label='3$\sigma$')
    axes[1,0].fill_between(x,x*0, x/3., hatch='\\\\', facecolor='None', linewidth=.0)
    axes[1,0].legend(loc=(0.5, 0.8))
    axes[1,1].plot(x, x/3., 'k--', label='3$\sigma$')
    axes[1,1].fill_between(x,x*0, x/3., hatch='\\\\', facecolor='None', linewidth=.0)
    axes[1,1].legend(loc=(0.5, 0.8))
    axes[1,0].set_xlim(0,0.06)
    axes[1,0].set_ylim(0.,0.02)
    axes[1,1].set_xlim(0,0.25)
    axes[1,1].set_ylim(0.,0.1)

@plot
def region_validation():
    gps = emulators["Pb-Pb-5020"].gps
    
    n = len(gps)
    fig, axes = plt.subplots(
        nrows=2, ncols=4,
        figsize=(2*textwidth, textwidth)
    )    
    d = Design('Pb-Pb-5020').__array__()
    r = np.array(Design('Pb-Pb-5020').range)
    nstd = []
    for gp in gps:
        mean, std = gp.predict(d, return_std=True)
        nstd.append( 10*std/(np.abs(mean)+std) )
    nstd = np.array(nstd)
    for i, ax in enumerate(axes.flatten()):
        ax.set_xlabel("param-1")
        ax.set_ylabel("param-2")
        ax.scatter(d[:,0],d[:,1],s=nstd[i],color='red',alpha=0.5)
        idmax = np.argmax(nstd[i])
        print((d[idmax]-r[:,0])/(r[:,1]-r[:,0]))

@plot
def diag_emu():
    """
    Diagnostic: plots of each principal component vs each input parameter,
    overlaid by emulator predictions at several points in design space.

    """
    gps = emulators["Pb-Pb-5020"].gps
    nrows = len(gps)
    ncols = gps[0].X_train_.shape[1]

    w = 1.8
    fig, axes = plt.subplots(
        nrows=nrows, ncols=ncols,
        figsize=(ncols*w, .8*nrows*w)
    )

    ymax = np.ceil(max(np.fabs(g.y_train_).max() for g in gps))
    ylim = (-ymax, ymax)

    design = Design("Pb-Pb-5020")

    for ny, (gp, row) in enumerate(zip(gps, axes)):
        y = gp.y_train_

        for nx, (x, label, xlim, ax) in enumerate(zip(
                gp.X_train_.T, design.labels, design.range, row
        )):
            ax.plot(x, y, 'o', ms=.8, color='.75', zorder=10)

            x = np.linspace(xlim[0], xlim[1], 100)
            X = np.empty((x.size, ncols))

            for k, r in enumerate([.2, .5, .8]):
                X[:] = r*design.min + (1 - r)*design.max
                X[:, nx] = x
                mean, std = gp.predict(X, return_std=True)

                color = plt.cm.tab10(k)
                ax.plot(x, mean, lw=.2, color=color, zorder=30)
                ax.fill_between(
                    x, mean - std, mean + std,
                    lw=0, color=color, alpha=.3, zorder=20
                )

            ax.set_xlim(xlim)
            ax.set_ylim(ylim)

            ax.set_xlabel(label)
            ax.set_ylabel('PC {}'.format(ny))


@plot
def find_map():
    """
    Find the maximum a posteriori (MAP) point and compare emulator predictions
    to experimental data.

    """
    from scipy.optimize import minimize
    chain = mcmc.Chain()

    fixed_params = {
        "lnmu" : 0.8
    }

    opt_params = [k for k in chain.keys if k not in fixed_params]

    def full_x(x):
        x = dict(zip(opt_params, x), **fixed_params)
        return [x[k] for k in chain.keys]

    res = minimize(
        lambda x: -chain.log_posterior(full_x(x))[0],
        x0=np.median(chain.load(*opt_params, thin=1000), axis=0),
        tol=1e-8,
        bounds=[
            (a + 1e-6*(b - a), b - 1e-6*(b - a))
            for (a, b), k in zip(chain.range, chain.keys)
            if k in opt_params
        ]
      )

    for k, v in zip(opt_params, res['x']):
        print(k, '=', v)

    preds = chain._predict(np.atleast_2d(full_x(res['x'])))
    obs(posterior=True, ratio=True, fmap=preds)
    


if __name__ == '__main__':
    import argparse
    from matplotlib.mathtext import MathTextWarning

    warnings.filterwarnings(
        'ignore',
        category=MathTextWarning,
        message='Substituting with a symbol from Computer Modern.'
    )

    choices = list(plot_functions)

    def arg_to_plot(arg):
        arg = Path(arg).stem
        if arg not in choices:
            raise argparse.ArgumentTypeError(arg)
        return arg

    parser = argparse.ArgumentParser(description='generate plots')
    parser.add_argument(
        'plots', nargs='*', type=arg_to_plot, metavar='PLOT',
        help='{} (default: all)'.format(', '.join(choices).join('{}'))
    )
    args = parser.parse_args()

    if args.plots:
        for p in args.plots:
            plot_functions[p]()
    else:
        for f in plot_functions.values():
            f()
